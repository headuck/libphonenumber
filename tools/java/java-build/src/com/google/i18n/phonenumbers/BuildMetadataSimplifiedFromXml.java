/*
 * Copyright (C) 2009 The Libphonenumber Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.i18n.phonenumbers;

import com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata;
import com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.Formatter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Tool to convert phone number metadata from the XML format to simplified format.
 *
 * Based on the name of the {@code inputFile}, some optimization and removal of unnecessary metadata
 * is carried out to reduce the size of the output file.
 *
 * @author Shaopeng Jia
 */
public class BuildMetadataSimplifiedFromXml extends Command {
  private static final String CLASS_NAME = BuildMetadataSimplifiedFromXml.class.getSimpleName();
  // private static final String PACKAGE_NAME = BuildMetadataSimplifiedFromXml.class.getPackage().getName();
  private static final String PACKAGE_NAME = "com.headuck.phonenumbers";

  // Command line parameter names.
  private static final String INPUT_FILE = "input-file";
  private static final String OUTPUT_DIR = "output-dir";
  private static final String DATA_PREFIX = "data-prefix";
  private static final String MAPPING_CLASS = "mapping-class";
  private static final String COPYRIGHT = "copyright";

  private static final String HELP_MESSAGE =
      "Usage: " + CLASS_NAME + " [OPTION]...\n" +
      "\n" +
      "  --" + INPUT_FILE + "=PATH     Read phone number metadata in XML format from PATH.\n" +
      "  --" + OUTPUT_DIR + "=PATH     Use PATH as the root directory for output files.\n" +
      "  --" + DATA_PREFIX +
          "=PATH    Use PATH (relative to " + OUTPUT_DIR + ") as the basename when\n" +
      "                        writing phone number metadata in proto format.\n" +
      "                        A single file will be written with\n" +
      "                        metadata for all regions.\n" +
      "  --" + MAPPING_CLASS + "=NAME  Store country code mappings in the class NAME, which\n" +
      "                        will be written to a file in " + OUTPUT_DIR + ".\n" +
      "  --" + COPYRIGHT + "=YEAR      Use YEAR in generated copyright headers.\n" +
      "\n" +
      "Example command line invocation:\n" +
      CLASS_NAME + " \\\n" +
      "  --" + INPUT_FILE + "=resources/PhoneNumberMetadata.xml \\\n" +
      "  --" + OUTPUT_DIR + "=java/libphonenumber/src/com/headuck/phonenumbers \\\n" +
      "  --" + DATA_PREFIX + "=data/PhoneNumberMetadataSimplified \\\n" +
      "  --" + MAPPING_CLASS + "=CountryCodeToRegionCodeMap \\\n" +
      "  --" + COPYRIGHT + "=2010 \n";

  private static final String GENERATION_COMMENT =
      "/* This file is automatically generated by {@link " + CLASS_NAME + "}.\n" +
      " * Please don't modify it directly.\n" +
      " */\n\n";

  @Override
  public String getCommandName() {
    return CLASS_NAME;
  }

  @Override
  public boolean start() {
    // The format of a well-formed command line parameter.
    Pattern pattern = Pattern.compile("--(.+?)=(.*)");

    String inputFile = null;
    String outputDir = null;
    String dataPrefix = null;
    String mappingClass = null;
    String copyright = null;

    for (int i = 1; i < getArgs().length; i++) {
      String key = null;
      String value = null;
      Matcher matcher = pattern.matcher(getArgs()[i]);
      if (matcher.matches()) {
        key = matcher.group(1);
        value = matcher.group(2);
      }

      if (INPUT_FILE.equals(key)) {
        inputFile = value;
      } else if (OUTPUT_DIR.equals(key)) {
        outputDir = value;
      } else if (DATA_PREFIX.equals(key)) {
        dataPrefix = value;
      } else if (MAPPING_CLASS.equals(key)) {
        mappingClass = value;
      } else if (COPYRIGHT.equals(key)) {
        copyright = value;
      } else {
        System.err.println(HELP_MESSAGE);
        System.err.println("Illegal command line parameter: " + getArgs()[i]);
        return false;
      }
    }

    if (inputFile == null ||
        outputDir == null ||
        dataPrefix == null ||
        mappingClass == null ||
        copyright == null) {
      System.err.println(HELP_MESSAGE);
      return false;
    }

    String filePrefix = new File(outputDir, dataPrefix).getPath();

    try {
      PhoneMetadataCollection metadataCollection =
          BuildMetadataFromXml.buildPhoneMetadataCollection(inputFile, true, false);
        FileOutputStream os = null;
        try {
            os = new FileOutputStream(new File(filePrefix));
            writeCountryToMetadataMap(metadataCollection, os);
        } finally {
            if (os != null)
                os.close();
        }
       Map<Integer, List<String>> countryCodeToRegionCodeMap =
          BuildMetadataFromXml.buildCountryCodeToRegionCodeMap(metadataCollection);

      writeCountryCallingCodeMappingToJavaFile(
          countryCodeToRegionCodeMap, outputDir, mappingClass, copyright);
    } catch (Exception e) {
      e.printStackTrace();
      return false;
    }
    System.out.println("Metadata code successfully generated.");
    return true;
  }

  private static final String MAP_COMMENT =
      "  // A mapping from a country code to the region codes which denote the\n" +
      "  // country/region represented by that country code. In the case of multiple\n" +
      "  // countries sharing a calling code, such as the NANPA countries, the one\n" +
      "  // indicated with \"isMainCountryForCode\" in the metadata should be first.\n";
  private static final String COUNTRY_CODE_SET_COMMENT =
      "  // A set of all country codes for which data is available.\n";
  private static final String REGION_CODE_SET_COMMENT =
      "  // A set of all region codes for which data is available.\n";
  private static final double CAPACITY_FACTOR = 0.75;
  private static final String CAPACITY_COMMENT =
      "    // The capacity is set to %d as there are %d different entries,\n" +
      "    // and this offers a load factor of roughly " + CAPACITY_FACTOR + ".\n";

  private static void writeCountryCallingCodeMappingToJavaFile(
      Map<Integer, List<String>> countryCodeToRegionCodeMap,
      String outputDir, String mappingClass, String copyright) throws IOException {
    // Find out whether the countryCodeToRegionCodeMap has any region codes or country
    // calling codes listed in it.
    boolean hasRegionCodes = false;
    for (List<String> listWithRegionCode : countryCodeToRegionCodeMap.values()) {
      if (!listWithRegionCode.isEmpty()) {
        hasRegionCodes = true;
        break;
      }
    }
    boolean hasCountryCodes = countryCodeToRegionCodeMap.size() > 1;

    ClassWriter writer = new ClassWriter(outputDir, mappingClass, copyright);

    int capacity = (int) (countryCodeToRegionCodeMap.size() / CAPACITY_FACTOR);
    if (hasRegionCodes && hasCountryCodes) {
      writeMap(writer, capacity, countryCodeToRegionCodeMap);
    } else if (hasCountryCodes) {
      writeCountryCodeSet(writer, capacity, countryCodeToRegionCodeMap.keySet());
    } else {
      List<String> regionCodeList = countryCodeToRegionCodeMap.get(0);
      capacity = (int) (regionCodeList.size() / CAPACITY_FACTOR);
      writeRegionCodeSet(writer, capacity, regionCodeList);
    }

    writer.writeToFile();
  }

  private static void writeMap(ClassWriter writer, int capacity,
                               Map<Integer, List<String>> countryCodeToRegionCodeMap) {
    writer.addToBody(MAP_COMMENT);

    writer.addToImports("java.util.ArrayList");
    writer.addToImports("java.util.HashMap");
    writer.addToImports("java.util.List");
    writer.addToImports("java.util.Map");

    writer.addToBody("  static Map<Integer, List<String>> getCountryCodeToRegionCodeMap() {\n");
    writer.formatToBody(CAPACITY_COMMENT, capacity, countryCodeToRegionCodeMap.size());
    writer.addToBody("    Map<Integer, List<String>> countryCodeToRegionCodeMap =\n");
    writer.addToBody("        new HashMap<Integer, List<String>>(" + capacity + ");\n");
    writer.addToBody("\n");
    writer.addToBody("    ArrayList<String> listWithRegionCode;\n");
    writer.addToBody("\n");

    for (Map.Entry<Integer, List<String>> entry : countryCodeToRegionCodeMap.entrySet()) {
      int countryCallingCode = entry.getKey();
      List<String> regionCodes = entry.getValue();
      writer.addToBody("    listWithRegionCode = new ArrayList<String>(" +
                       regionCodes.size() + ");\n");
      for (String regionCode : regionCodes) {
        writer.addToBody("    listWithRegionCode.add(\"" + regionCode + "\");\n");
      }
      writer.addToBody("    countryCodeToRegionCodeMap.put(" + countryCallingCode +
                       ", listWithRegionCode);\n");
      writer.addToBody("\n");
    }

    writer.addToBody("    return countryCodeToRegionCodeMap;\n");
    writer.addToBody("  }\n");
  }

  private static void writeRegionCodeSet(ClassWriter writer, int capacity,
                                         List<String> regionCodeList) {
    writer.addToBody(REGION_CODE_SET_COMMENT);

    writer.addToImports("java.util.HashSet");
    writer.addToImports("java.util.Set");

    writer.addToBody("  static Set<String> getRegionCodeSet() {\n");
    writer.formatToBody(CAPACITY_COMMENT, capacity, regionCodeList.size());
    writer.addToBody("    Set<String> regionCodeSet = new HashSet<String>(" + capacity + ");\n");
    writer.addToBody("\n");

    for (String regionCode : regionCodeList) {
      writer.addToBody("    regionCodeSet.add(\"" + regionCode + "\");\n");
    }

    writer.addToBody("\n");
    writer.addToBody("    return regionCodeSet;\n");
    writer.addToBody("  }\n");
  }

  private static void writeCountryCodeSet(ClassWriter writer, int capacity,
                                          Set<Integer> countryCodeSet) {
    writer.addToBody(COUNTRY_CODE_SET_COMMENT);

    writer.addToImports("java.util.HashSet");
    writer.addToImports("java.util.Set");

    writer.addToBody("  static Set<Integer> getCountryCodeSet() {\n");
    writer.formatToBody(CAPACITY_COMMENT, capacity, countryCodeSet.size());
    writer.addToBody("    Set<Integer> countryCodeSet = new HashSet<Integer>(" + capacity + ");\n");
    writer.addToBody("\n");

    for (int countryCallingCode : countryCodeSet) {
      writer.addToBody("    countryCodeSet.add(" + countryCallingCode + ");\n");
    }

    writer.addToBody("\n");
    writer.addToBody("    return countryCodeSet;\n");
    writer.addToBody("  }\n");
  }

  private static final class ClassWriter {
    private final String name;
    private final String copyright;

    private final SortedSet<String> imports;
    private final StringBuffer body;
    private final Formatter formatter;
    private final Writer writer;

    ClassWriter(String outputDir, String name, String copyright) throws IOException {
      this.name = name;
      this.copyright = copyright;

      imports = new TreeSet<String>();
      body = new StringBuffer();
      formatter = new Formatter(body);
      writer = new BufferedWriter(new FileWriter(new File(outputDir, name + ".java")));
    }

    void addToImports(String name) {
      imports.add(name);
    }

    void addToBody(CharSequence text) {
      body.append(text);
    }

    void formatToBody(String format, Object... args) {
      formatter.format(format, args);
    }

    void writeToFile() throws IOException {
      CopyrightNotice.writeTo(writer, Integer.valueOf(copyright));
      writer.write(GENERATION_COMMENT);
      writer.write("package " + PACKAGE_NAME + ";\n\n");

      if (!imports.isEmpty()) {
        for (String item : imports) {
          writer.write("import " + item + ";\n");
        }
        writer.write("\n");
      }

      writer.write("public class " + name + " {\n");
      writer.write(body.toString());
      writer.write("}\n");

      writer.flush();
      writer.close();
    }
  }


    // Writes a PhoneMetadataCollection in custom and simplified format.
    private static void writeCountryToMetadataMap(PhoneMetadataCollection metadataCollection,
                                                  FileOutputStream os) throws IOException {
        // writer.write("{\n");
        // boolean isFirstTimeInLoop = true;
        RegexBufBuilder jsArrayBuilder = new RegexBufBuilder();
        
        int lastpos, ret;
        
        // First 2 bytes: length of metadata list
        int len = metadataCollection.getMetadataList().size();

        byte[] lenBuf = new byte [2];

        lenBuf[0] = (byte) (len >>> 8);
        lenBuf[1] = (byte) (len % 256);
        os.write(lenBuf);

        // Index buffer
        short [] idxbuf = new short [len*3];

        lastpos = 0;

        int idx = 0;
        for (PhoneMetadata metadata : metadataCollection.getMetadataList()) {

            String key = metadata.getId();
            // For non-geographical country calling codes (e.g. +800), use the country calling codes
            // instead of the region code as key in the map.
            if (key.equals("001")) {
                int ccode = metadata.getCountryCode();
                lenBuf[0] = (byte) (ccode >>> 8);
                lenBuf[1] = (byte) (ccode % 256);
            } else {
                lenBuf[0] = (byte) (key.charAt(0));
                lenBuf[1] = (byte) (key.charAt(1));
            }
            os.write(lenBuf);

            // Write to index buf, for subsequent verification
            idxbuf[idx * 3] = (short) ((lenBuf[0] & 0xFF) * 256 + (lenBuf[1] & 0xFF));

            ret = toJsArray(metadata, jsArrayBuilder);
            jsArrayBuilder.appendTerminator();
            int pos = jsArrayBuilder.length();
            short recordlen = (short) (pos - lastpos);
            lastpos = pos;

            lenBuf[0] = (byte) (recordlen >>> 8);
            lenBuf[1] = (byte) (recordlen % 256);
            os.write (lenBuf);
            idxbuf[idx * 3 + 1] = (short) recordlen;

            // writer.write (Integer.toString(recordlen));
            lenBuf[0] = (byte) (ret >>> 8);
            lenBuf[1] = (byte) (ret % 256);
            os.write (lenBuf);
            idxbuf[idx * 3 + 2] = (short) ret;
            // writer.write (Integer.toString(ret));
            idx ++;
        }
        //writer.write ("\n");
        byte[] encodedString = jsArrayBuilder.encodeString();
        os.write(encodedString, 0, jsArrayBuilder.encodedLength());
        System.out.println("Buffer length written = " + jsArrayBuilder.encodedLength() );

        // Restore Buffer in string form and compare with jsArrayBuilder
        String outputStr = Utils.expandBuf(idxbuf, encodedString);
        if (outputStr.equals(jsArrayBuilder.toString())) {
            System.out.println("Encoded and decoded data matches");
        } else {
            System.out.println("Encoded and decoded data mismatches");
        }
        //writer.write ("\n");
        // writer.write("}");
    }


    // Converts PhoneNumberDesc to JSArray.
    private static void toJsArray(int code, Phonemetadata.PhoneNumberDesc desc, RegexBufBuilder jsArrayBuilder) {
        if (desc == null) {
            // Some descriptions are optional; in these cases we just return if they are
            // absent.
            jsArrayBuilder.append(null);
            return;
        }
        // jsArrayBuilder.beginArray();

        // missing 0
        jsArrayBuilder.append(null);
        // missing 1
        jsArrayBuilder.append(null);
        // optional string national_number_pattern = 2;
        if (desc.hasNationalNumberPattern()) {
            jsArrayBuilder.append(code, desc.getNationalNumberPattern());
        } else {
            jsArrayBuilder.append(null);
        }
        // missing 3
        // jsArrayBuilder.append(null);

        // optional:
        // Only for general_desc (code == 1), with output field code set to 0
        // output the possible lengths for the pattern 
        // encoded in a bit mask, 1 for corresponding bit position
        if (code == 1) {
            int possibleLengthSize = desc.getPossibleLengthCount();
            int bits = 0;
            if (possibleLengthSize > 0) {
                for (int i = 0; i < possibleLengthSize; i++) {
                    int possibleLen = desc.getPossibleLength(i);
                    bits |= 1 << possibleLen;
                }
                jsArrayBuilder.append(0, Integer.toString(bits));
            // if (!desc.possibleNumberPattern.equals("")) {
            //     jsArrayBuilder.append(0, desc.possibleNumberPattern);

            } else {
                jsArrayBuilder.append(null);
            }
        }


        // missing 4
        jsArrayBuilder.append(null);
        // missing 5
        jsArrayBuilder.append(null);

        // optional string example_number = 6;
        /*
        if (!desc.exampleNumber.equals("")) {
            jsArrayBuilder.append(desc.exampleNumber);
        } else {
            jsArrayBuilder.append(null);
        }
        */
        // jsArrayBuilder.endArray();
    }

    /** 
     * Converts PhoneMetadata to custom representation.
     * @param metadata Phone metedata object
     * @param jsArrayBuilder Buffer builder to output the representation
     * @return integer representing the country code (if available) plus binary flags
     *         representing some of the metadata fields
     */ 
    private static int toJsArray(PhoneMetadata metadata, RegexBufBuilder jsArrayBuilder) {
        // jsArrayBuilder.beginArray();
        int ret = 0;    
        // Metadata binary flags to be encoded
        final int FLAG_SAME_MOBILE_FIXED = 1024;
        final int FLAG_MAIN_COUNTRY_FOR_CODE = 2048;
        final int FLAG_LEADING_ZERO_POSSIBLE = 4096;
        final int FLAG_MOBILE_PORTABLE_REGION = 8192;
        
        // missing 0
        jsArrayBuilder.append(null);
        // optional PhoneNumberDesc general_desc = 1;
        toJsArray(1, metadata.getGeneralDesc(), jsArrayBuilder);
        // optional PhoneNumberDesc fixed_line = 2;
        toJsArray(2, metadata.getFixedLine(), jsArrayBuilder);
        // optional PhoneNumberDesc mobile = 3;
        toJsArray(3, metadata.getMobile(), jsArrayBuilder);
        // optional PhoneNumberDesc toll_free = 4;
        toJsArray(4, metadata.getTollFree(), jsArrayBuilder);
        // optional PhoneNumberDesc premium_rate = 5;
        toJsArray(5, metadata.getPremiumRate(), jsArrayBuilder);
        // optional PhoneNumberDesc shared_cost = 6;
        toJsArray(6, metadata.getSharedCost(), jsArrayBuilder);
        // optional PhoneNumberDesc personal_number = 7;
        toJsArray(7, metadata.getPersonalNumber(), jsArrayBuilder);
        // optional PhoneNumberDesc voip = 8;
        toJsArray(8, metadata.getVoip(), jsArrayBuilder);

        // required string id = 9;
        // jsArrayBuilder.append(metadata.id);
        // optional int32 country_code = 10;
        if (metadata.hasCountryCode()) {
            ret += metadata.getCountryCode();
        } else {
            jsArrayBuilder.append(null);
        }
            
        // optional string international_prefix = 11;
        // TODO: Don't set in format if default to begin with, and replace this check with "has".
        if (metadata.getInternationalPrefix().length() > 0) {
            jsArrayBuilder.append(11, metadata.getInternationalPrefix());
        } else {
            jsArrayBuilder.append(null);
        }
        
        /*
        // optional string national_prefix = 12;
        if (metadata.hasNationalPrefix()) {
          jsArrayBuilder.append(metadata.getNationalPrefix());
        } else {
          jsArrayBuilder.append(null);
        }
        // optional string preferred_extn_prefix = 13;
        if (metadata.hasPreferredExtnPrefix()) {
          jsArrayBuilder.append(metadata.getPreferredExtnPrefix());
        } else {
          jsArrayBuilder.append(null);
        }
        // missing 14
        jsArrayBuilder.append(null);
        // optional string national_prefix_for_parsing = 15;
        if (metadata.hasNationalPrefixForParsing()) {
          jsArrayBuilder.append(metadata.getNationalPrefixForParsing());
        } else {
          jsArrayBuilder.append(null);
        }
        // optional string national_prefix_transform_rule = 16;
        if (metadata.hasNationalPrefixTransformRule()) {
          jsArrayBuilder.append(metadata.getNationalPrefixTransformRule());
        } else {
          jsArrayBuilder.append(null);
        }
        // optional string preferred_international_prefix = 17;
        if (metadata.hasPreferredInternationalPrefix()) {
          jsArrayBuilder.append(metadata.getPreferredInternationalPrefix());
        } else {
          jsArrayBuilder.append(null);
        }
        */
        // optional bool same_mobile_and_fixed_line_pattern = 18 [default=false];
        if (metadata.getSameMobileAndFixedLinePattern()) {
          // jsArrayBuilder.append(1);
            ret |= FLAG_SAME_MOBILE_FIXED;
        } else {
            jsArrayBuilder.append(null);
        }
        /*
        // repeated NumberFormat number_format = 19;
        int numberFormatSize = metadata.numberFormatSize();
        if (numberFormatSize > 0) {
          jsArrayBuilder.beginArray();
          for (int i = 0; i < numberFormatSize; i++) {
            toJsArray(metadata.getNumberFormat(i), jsArrayBuilder);
          }
          jsArrayBuilder.endArray();
        } else {
          jsArrayBuilder.append(null);
        }
        // repeated NumberFormat intl_number_format = 20;
        int intlNumberFormatSize = metadata.intlNumberFormatSize();
        if (intlNumberFormatSize > 0) {
          jsArrayBuilder.beginArray();
          for (int i = 0; i < intlNumberFormatSize; i++) {
            toJsArray(metadata.getIntlNumberFormat(i), jsArrayBuilder);
          }
          jsArrayBuilder.endArray();
        } else {
          jsArrayBuilder.append(null);
        }
        */
        
        // optional PhoneNumberDesc pager = 21;
        toJsArray(21, metadata.getPager(), jsArrayBuilder);

        // optional bool main_country_for_code = 22 [default=false];
        if (metadata.isMainCountryForCode()) {
            // jsArrayBuilder.append(1);
            ret |= FLAG_MAIN_COUNTRY_FOR_CODE;
        } else {
            jsArrayBuilder.append(null);
        }
        
        // optional string leading_digits = 23;
        if (!metadata.hasLeadingDigits()) {
            jsArrayBuilder.append(23, metadata.getLeadingDigits());
        } else {
            jsArrayBuilder.append(null);
        }
        // optional PhoneNumberDesc no_international_dialling = 24;
        // toJsArray(metadata.getNoInternationalDialling(), jsArrayBuilder);
        
        // optional PhoneNumberDesc uan = 25;
        toJsArray(25, metadata.getUan(), jsArrayBuilder);

        // optional bool leading_zero_possible = 26 [default=false];
        if (metadata.isLeadingZeroPossible()) {
            ret |= FLAG_LEADING_ZERO_POSSIBLE;
            // jsArrayBuilder.append(1);
        } else {
            jsArrayBuilder.append(null);
        }
        // optional PhoneNumberDesc emergency = 27;
        // toJsArray(metadata.getEmergency(), jsArrayBuilder);
        // optional PhoneNumberDesc voicemail = 28;
        toJsArray(28, metadata.getVoicemail(), jsArrayBuilder);
        // Fields 29-31 are omitted due to space increase.
        // optional PhoneNumberDesc short_code = 29;
        // optional PhoneNumberDesc standard_rate = 30;
        // optional PhoneNumberDesc carrier_specific = 31;
        // optional bool mobile_number_portable_region = 32 [default=false];
        if (metadata.isMobileNumberPortableRegion()) {
            ret |= FLAG_MOBILE_PORTABLE_REGION;
        }
        // Omit since the JS API doesn't expose this data.
        // Note: Need to add null for each of the above fields when a subsequent
        // field is being populated.

        // jsArrayBuilder.endArray();
        return ret;
    }
    static final byte CODE_D = 11;
    static final byte CODE_OPEN_SQUARE = 12;
    static final byte CODE_CLOSE_SQUARE = 13;
    static final byte CODE_OPEN_BRACKET = 14;
    static final byte CODE_CLOSE_BRACKET = 15;
    static final byte CODE_CHOICE = 16;
    static final byte CODE_COMMA = 17;
    static final byte CODE_RANGE = 18;
    static final byte CODE_BACKSLASH = 19;
    static final byte CODE_OPTION = 20;
    static final byte CODE_SEMICOLON = 21;
    static final byte CODE_SEPARATOR = 31;
    static final byte CODE_TERMINATOR = 0;

    private static class RegexBufBuilder implements CharSequence {
        // Internal representation.
        private StringBuilder data = new StringBuilder();
        boolean first = true;

        // 1. replace ( with \( unless followed by '?:'
        Pattern pattern1 = Pattern.compile("\\((?!\\?:)");
        // 2. replace (?: with (
        Pattern pattern2 = Pattern.compile("\\(\\?:");
        // 3. replace \d{  or \d (unless followed by digit) with d
        Pattern pattern3 = Pattern.compile("\\\\d\\{|\\\\d(?!\\d)");
        // 4. remove '}' in 'd#,#}' unless followed by another digit
        Pattern pattern4 = Pattern.compile("(?<=d\\d\\d?(?:,\\d\\d?)?)\\}(?!\\d)");

        public RegexBufBuilder append(String string) {
            if (string != null) {
                throw new RuntimeException("null expected in append(String)");
            }
            return this;
        }

        public RegexBufBuilder append(int fieldCode, String string) {
            if ((string != null) && !"NA".equals(string)) {
                if (!first) {
                    appendSeparator();
                } else {
                    first = false;
                }
                // assumes no ; and \n
                data.append ((char)('A' + fieldCode));

                data.append(process(string));
            }
            return this;
        }

        private String process (String string) {
            Matcher matcher1 = pattern1.matcher(string);
            String string1 = matcher1.replaceAll("\\\\(");  // \ also needs double escapes here!
            Matcher matcher2 = pattern2.matcher(string1);
            String string2 = matcher2.replaceAll("(");
            Matcher matcher3 = pattern3.matcher(string2);
            String string3 = matcher3.replaceAll("d");

            Matcher matcher4 = pattern4.matcher(string3);
            String string4 = matcher4.replaceAll("");
            String expandedTest = Utils.expandRegex(string4);
            if (!string.equals(expandedTest)) {
                System.out.println("Warning: string mismatch after compress and expand: " + string +
                        " compressed:" + string4 + " expanded:" + expandedTest);
            }
            return string4;
        }

        public RegexBufBuilder appendSeparator() {
            data.append (";");
            return this;
        }

        public RegexBufBuilder appendTerminator() {
            data.append ("\n");
            first = true;
            return this;
        }

        // Returns a string representing the data
        @Override public String toString() {
            return data.toString();
        }


        public char charAt(int index) {
            return data.charAt(index);
        }


        public int length() {
            return data.length();
        }

        public CharSequence subSequence(int start, int end) {
            return data.subSequence(start, end);
        }

        static int bitpos;
        static byte[] byteBuf;
        static int byteBufIdx = -1;
        
        /**
         * Encode the string into buffer, 5 bits for each char
         * @return byte[] of the encoded string. The length of the last encoded 
         * string can be separately retrieved from {@link #encodedLength()}
         */
        public byte[] encodeString() {
            // Internal buffer representation
            int bufLen = (data.length() * 5 + 7)/ 8;
            System.out.println("Output buffer size: " + bufLen);
            bitpos = 0;
            byteBuf = new byte[bufLen];
            byteBufIdx = 0;
            byteBuf[0] = 0;
            int strLen = data.length();
            boolean first = true;
            for (int i = 0; i < strLen; i++) {
                if (first) {
                    // encode field name
                    encodeByte((byte)(data.charAt(i) - 'A'));
                    first = false;
                } else if (data.charAt(i) == ';') {
                    // write separator
                    encodeByte(CODE_SEPARATOR);
                    first = true;
                } else if (data.charAt(i) == '\n') {
                    // write terminator
                    encodeByte(CODE_TERMINATOR);
                    first = true;
                } else {
                    //if (data.charAt(i) == '\\' && (i+1 < strLen) && data.charAt(i+1) == ';') {
                        // escaped next ;
                    //    skipperLen ++;
                    //    i++;
                    //}
                    encodeChar(data.charAt(i));
                }
            }
            return byteBuf;
        }
        
        public static int encodedLength() {
            // byteBufIdx is the last written pos. Length = byteBufIdx + 1
            return byteBufIdx + 1;
        }

        private void encodeByte(byte b) {
            boolean next = false;
            if (bitpos <= 7) {
                // write to current byte
                if (bitpos <= 3) {
                    byteBuf[byteBufIdx] |= (byte) (b << (3 - bitpos));
                    bitpos += 5;
                } else {
                    byteBuf[byteBufIdx] |= (byte) ((b & 0xFF) >>> (bitpos - 3));
                    bitpos -= 3;
                    next = true;
                }
            } else {
                bitpos -= 3;
                next = true;
            }
            if (next) {
                // need to write to next byte and advance ptr, and split byte
                byteBufIdx ++;
                byteBuf[byteBufIdx] = (byte) (b << (8 - bitpos));
            }
        }



        private void encodeChar(char c) {
            if (Character.isDigit(c)) {
                // 0-9 -> 1-10
                encodeByte((byte)(c-'0'+ 1));
            } else switch (c){
                case 'd':
                    //d -> 11
                    encodeByte (CODE_D);
                    break;
                case '[':
                    encodeByte (CODE_OPEN_SQUARE);
                    break;
                case ']':
                    encodeByte (CODE_CLOSE_SQUARE);
                    break;
                case '(':
                    encodeByte (CODE_OPEN_BRACKET);
                    break;
                case ')':
                    encodeByte (CODE_CLOSE_BRACKET);
                    break;
                case '|':
                    encodeByte (CODE_CHOICE);
                    break;
                case ',':
                    encodeByte (CODE_COMMA);
                    break;
                case '-':
                    encodeByte (CODE_RANGE);
                    break;
                case '\\':
                    encodeByte (CODE_BACKSLASH);
                    break;
                case '?':
                    encodeByte (CODE_OPTION);
                    break;
                case ';':
                    encodeByte (CODE_SEMICOLON);
                    break;
                default:
                    System.out.println("Invalid char during encoding: " + c);
                    break;
            }
        }
    }

    
    private static class Utils {
        
        /**
         * Expand into original regular expression
         *  1. expand ( to (?:, escaped \( to (
         *  2. replace d with \d
         *  3. following d, replace any #[,#] / #[,#]} with {#[,#} except when d is escaped
         *  4. also unescape \; if any
         * @param string string to expand
         * @return expanded expression
         */
        public static String expandRegex(String string) {
            StringBuilder sb = new StringBuilder();
            int strlen = string.length();
            boolean inCurly = false;
            boolean afterComma = false;
            boolean afterD = false;
            boolean escape = false;
            for (int i = 0; i < strlen; i++) {
                char c = string.charAt(i);
                if (c == '\\') {
                    escape = true;
                    continue;
                }
                if (Character.isDigit(c)) {
                    if (afterD) {
                        if (escape) {  // should not happen?
                            sb.append('\\');
                            escape = false;
                        }
                        sb.append('{');
                        afterD = false;
                        inCurly = true;
                    }
                } else {
                    if (afterD) afterD = false;
                    if (inCurly) {
                        if (!afterComma && (c==',')) {
                            afterComma = true;
                        } else {
                            if (c != '}') {
                                if (escape) {  // should not happen?
                                    sb.append('\\');
                                    escape = false;
                                }
                                sb.append('}');
                            }
                            inCurly = false;
                            afterComma = false;
                        }
                    }
                }
                if (c == '(') {
                    if (escape) {
                        sb.append("(");   // \( -> (
                        escape = false;
                    } else {
                        sb.append("(?:");
                    }
                } else if (c =='d') {
                    sb.append("\\d");
                    if (!escape) {
                        afterD = true;    // escaped if followed by real digit not in curry
                    } else {
                        escape = false;
                    }
                } else {
                    if (escape) {
                        if ((c != '\\') && (c != ';')) {
                            sb.append('\\');    // \\ -> \  \; -> ; otherwise don't delete \
                        }
                        escape = false;
                    }
                    sb.append(c);
                }

            }
            if (escape) sb.append ('\\');
            if (inCurly) sb.append('}');
            return sb.toString();
        }

        public static String expandBuf(short[] idxbuf,  byte[] buffer) {
            int len = idxbuf.length / 3;
            int pos = 0;
            StringBuilder sb = new StringBuilder();
            for (int i=0; i<len; i++) {
                short id = idxbuf[i * 3];
                String key;
                if (id > 1000) {
                    // should be two character id
                    key = "" + (char) (id >>> 8) +  (char)(id % 256);
                } else {
                    key = Integer.toString(id);
                }
                short code = idxbuf[i*3 + 2];
                String ccode = Integer.toString(code & 1023);
                // final int FLAG_SAME_MOBILE_FIXED = 1024;
                // final int FLAG_MAIN_COUNTRY_FOR_CODE = 2048;
                // final int FLAG_LEADING_ZERO_POSSIBLE = 4096;
                // final int FLAG_MOBILE_PORTABLE_REGION = 8192;
                short bufLen = idxbuf[i*3 + 1];
                // Buffer is at offset pos
                String record = getCountryRecord(buffer, pos);
                sb.append(record);
                // System.out.println(key + ": code=" + ccode + " record:" + record + " buflen:" + bufLen);
                pos += bufLen;
            }
            return sb.toString();
        }

        /**
         * Retrieve & expand 5-bit buffer to String at pos (counted at 5 bit length)
         * @param buffer
         * @return String of the record
         */
        private static String getCountryRecord(byte[]buffer, int pos) {
            // Calculate start bit & byte offset
            StringBuilder sb = new StringBuilder();
            byte data;
            int bitpos = pos * 5;
            int bytepos = bitpos / 8;
            final int bufferLen = buffer.length;
            bitpos = bitpos % 8;
            boolean first = true;
            while (true) {
                if (bitpos <= 3) {
                    // retrieve from the buf at bytepos
                    data = (byte) (((buffer[bytepos] & 0xFF) >>> (3 - bitpos)) & 31);
                    bitpos += 5;
                } else {
                    // need to advance to next buf byte
                    if (bitpos < 8) {
                        data = (byte) ((buffer[bytepos] << (bitpos - 3)) & 31);
                    } else {
                        data = 0;
                    }
                    bytepos ++;
                    if (bytepos >= bufferLen) {
                        System.out.println("Unexpected end of buffer");
                        break;
                    }
                    // System.out.println(" " + bytepos + ": " + buffer[bytepos]);
                    data |= (byte) (((buffer[bytepos] & 0xFF) >>> (8 - bitpos + 3)) & 31);
                    bitpos -= 3;
                }
                // process data

                char chr = decodeProcess(first, data);
                if (chr != ' ') {
                    sb.append(chr);
                }
                if (first) {
                    first = false;
                } else {
                    if (data == CODE_TERMINATOR) {
                        break;
                    }
                    if (data == CODE_SEPARATOR) {
                        first = true;
                    }
                }
            }
            return sb.toString();

        }

        static final char[] decodeTable = new char[] {
            'd', '[', ']', '(', ')', '|', ',', '-', '\\', '?', ';'
        };

        private static char decodeProcess(boolean first, byte data) {
            // Return the char representation of data
            if (first) {
                return (char) (data + 'A');
            }
            if ((data >= 1) && (data <= 10)) {
                return (char) ('0' + data - 1);
            }
            if (data == CODE_SEPARATOR) {
                return ';';
            }
            if (data == CODE_TERMINATOR) {
                return '\n';
            }

            int pos = data - CODE_D;
            if ((pos >=0) && (pos < decodeTable.length)) {
                return decodeTable[pos];
            }

            System.out.println("Invalid code: " + data);
            return ' ';
        }
    }


}
