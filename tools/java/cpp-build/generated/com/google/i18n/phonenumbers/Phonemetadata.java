// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: phonemetadata.proto

package com.google.i18n.phonenumbers;

public final class Phonemetadata {
  private Phonemetadata() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface NumberFormatOrBuilder extends
      // @@protoc_insertion_point(interface_extends:i18n.phonenumbers.NumberFormat)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required string pattern = 1;</code>
     *
     * <pre>
     * pattern is a regex that is used to match the national (significant)
     * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
     * "2070313000", which is the national (significant) number for Google London.
     * Note the presence of the parentheses, which are capturing groups what
     * specifies the grouping of numbers.
     * </pre>
     */
    boolean hasPattern();
    /**
     * <code>required string pattern = 1;</code>
     *
     * <pre>
     * pattern is a regex that is used to match the national (significant)
     * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
     * "2070313000", which is the national (significant) number for Google London.
     * Note the presence of the parentheses, which are capturing groups what
     * specifies the grouping of numbers.
     * </pre>
     */
    java.lang.String getPattern();
    /**
     * <code>required string pattern = 1;</code>
     *
     * <pre>
     * pattern is a regex that is used to match the national (significant)
     * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
     * "2070313000", which is the national (significant) number for Google London.
     * Note the presence of the parentheses, which are capturing groups what
     * specifies the grouping of numbers.
     * </pre>
     */
    com.google.protobuf.ByteString
        getPatternBytes();

    /**
     * <code>required string format = 2;</code>
     *
     * <pre>
     * format specifies how the national (significant) number matched by
     * pattern should be formatted.
     * Using the same example as above, format could contain "$1 $2 $3",
     * meaning that the number should be formatted as "20 7031 3000".
     * Each $x are replaced by the numbers captured by group x in the
     * regex specified by pattern.
     * </pre>
     */
    boolean hasFormat();
    /**
     * <code>required string format = 2;</code>
     *
     * <pre>
     * format specifies how the national (significant) number matched by
     * pattern should be formatted.
     * Using the same example as above, format could contain "$1 $2 $3",
     * meaning that the number should be formatted as "20 7031 3000".
     * Each $x are replaced by the numbers captured by group x in the
     * regex specified by pattern.
     * </pre>
     */
    java.lang.String getFormat();
    /**
     * <code>required string format = 2;</code>
     *
     * <pre>
     * format specifies how the national (significant) number matched by
     * pattern should be formatted.
     * Using the same example as above, format could contain "$1 $2 $3",
     * meaning that the number should be formatted as "20 7031 3000".
     * Each $x are replaced by the numbers captured by group x in the
     * regex specified by pattern.
     * </pre>
     */
    com.google.protobuf.ByteString
        getFormatBytes();

    /**
     * <code>repeated string leading_digits_pattern = 3;</code>
     *
     * <pre>
     * This field is a regex that is used to match a certain number of digits
     * at the beginning of the national (significant) number. When the match is
     * successful, the accompanying pattern and format should be used to format
     * this number. For example, if leading_digits="[1-3]|44", then all the
     * national numbers starting with 1, 2, 3 or 44 should be formatted using the
     * accompanying pattern and format.
     * The first leadingDigitsPattern matches up to the first three digits of the
     * national (significant) number; the next one matches the first four digits,
     * then the first five and so on, until the leadingDigitsPattern can uniquely
     * identify one pattern and format to be used to format the number.
     * In the case when only one formatting pattern exists, no
     * leading_digits_pattern is needed.
     * </pre>
     */
    com.google.protobuf.ProtocolStringList
        getLeadingDigitsPatternList();
    /**
     * <code>repeated string leading_digits_pattern = 3;</code>
     *
     * <pre>
     * This field is a regex that is used to match a certain number of digits
     * at the beginning of the national (significant) number. When the match is
     * successful, the accompanying pattern and format should be used to format
     * this number. For example, if leading_digits="[1-3]|44", then all the
     * national numbers starting with 1, 2, 3 or 44 should be formatted using the
     * accompanying pattern and format.
     * The first leadingDigitsPattern matches up to the first three digits of the
     * national (significant) number; the next one matches the first four digits,
     * then the first five and so on, until the leadingDigitsPattern can uniquely
     * identify one pattern and format to be used to format the number.
     * In the case when only one formatting pattern exists, no
     * leading_digits_pattern is needed.
     * </pre>
     */
    int getLeadingDigitsPatternCount();
    /**
     * <code>repeated string leading_digits_pattern = 3;</code>
     *
     * <pre>
     * This field is a regex that is used to match a certain number of digits
     * at the beginning of the national (significant) number. When the match is
     * successful, the accompanying pattern and format should be used to format
     * this number. For example, if leading_digits="[1-3]|44", then all the
     * national numbers starting with 1, 2, 3 or 44 should be formatted using the
     * accompanying pattern and format.
     * The first leadingDigitsPattern matches up to the first three digits of the
     * national (significant) number; the next one matches the first four digits,
     * then the first five and so on, until the leadingDigitsPattern can uniquely
     * identify one pattern and format to be used to format the number.
     * In the case when only one formatting pattern exists, no
     * leading_digits_pattern is needed.
     * </pre>
     */
    java.lang.String getLeadingDigitsPattern(int index);
    /**
     * <code>repeated string leading_digits_pattern = 3;</code>
     *
     * <pre>
     * This field is a regex that is used to match a certain number of digits
     * at the beginning of the national (significant) number. When the match is
     * successful, the accompanying pattern and format should be used to format
     * this number. For example, if leading_digits="[1-3]|44", then all the
     * national numbers starting with 1, 2, 3 or 44 should be formatted using the
     * accompanying pattern and format.
     * The first leadingDigitsPattern matches up to the first three digits of the
     * national (significant) number; the next one matches the first four digits,
     * then the first five and so on, until the leadingDigitsPattern can uniquely
     * identify one pattern and format to be used to format the number.
     * In the case when only one formatting pattern exists, no
     * leading_digits_pattern is needed.
     * </pre>
     */
    com.google.protobuf.ByteString
        getLeadingDigitsPatternBytes(int index);

    /**
     * <code>optional string national_prefix_formatting_rule = 4;</code>
     *
     * <pre>
     * This field specifies how the national prefix ($NP) together with the first
     * group ($FG) in the national significant number should be formatted in
     * the NATIONAL format when a national prefix exists for a certain country.
     * For example, when this field contains "($NP$FG)", a number from Beijing,
     * China (whose $NP = 0), which would by default be formatted without
     * national prefix as 10 1234 5678 in NATIONAL format, will instead be
     * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
     * would contain "($NP)$FG". Note $FG should always be present in this field,
     * but $NP can be omitted. For example, having "$FG" could indicate the
     * number should be formatted in NATIONAL format without the national prefix.
     * This is commonly used to override the rule specified for the territory in
     * the XML file.
     * When this field is missing, a number will be formatted without national
     * prefix in NATIONAL format. This field does not affect how a number
     * is formatted in other formats, such as INTERNATIONAL.
     * </pre>
     */
    boolean hasNationalPrefixFormattingRule();
    /**
     * <code>optional string national_prefix_formatting_rule = 4;</code>
     *
     * <pre>
     * This field specifies how the national prefix ($NP) together with the first
     * group ($FG) in the national significant number should be formatted in
     * the NATIONAL format when a national prefix exists for a certain country.
     * For example, when this field contains "($NP$FG)", a number from Beijing,
     * China (whose $NP = 0), which would by default be formatted without
     * national prefix as 10 1234 5678 in NATIONAL format, will instead be
     * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
     * would contain "($NP)$FG". Note $FG should always be present in this field,
     * but $NP can be omitted. For example, having "$FG" could indicate the
     * number should be formatted in NATIONAL format without the national prefix.
     * This is commonly used to override the rule specified for the territory in
     * the XML file.
     * When this field is missing, a number will be formatted without national
     * prefix in NATIONAL format. This field does not affect how a number
     * is formatted in other formats, such as INTERNATIONAL.
     * </pre>
     */
    java.lang.String getNationalPrefixFormattingRule();
    /**
     * <code>optional string national_prefix_formatting_rule = 4;</code>
     *
     * <pre>
     * This field specifies how the national prefix ($NP) together with the first
     * group ($FG) in the national significant number should be formatted in
     * the NATIONAL format when a national prefix exists for a certain country.
     * For example, when this field contains "($NP$FG)", a number from Beijing,
     * China (whose $NP = 0), which would by default be formatted without
     * national prefix as 10 1234 5678 in NATIONAL format, will instead be
     * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
     * would contain "($NP)$FG". Note $FG should always be present in this field,
     * but $NP can be omitted. For example, having "$FG" could indicate the
     * number should be formatted in NATIONAL format without the national prefix.
     * This is commonly used to override the rule specified for the territory in
     * the XML file.
     * When this field is missing, a number will be formatted without national
     * prefix in NATIONAL format. This field does not affect how a number
     * is formatted in other formats, such as INTERNATIONAL.
     * </pre>
     */
    com.google.protobuf.ByteString
        getNationalPrefixFormattingRuleBytes();

    /**
     * <code>optional bool national_prefix_optional_when_formatting = 6;</code>
     *
     * <pre>
     * This field specifies whether the $NP can be omitted when formatting a
     * number in national format, even though it usually wouldn't be. For example,
     * a UK number would be formatted by our library as 020 XXXX XXXX. If we have
     * commonly seen this number written by people without the leading 0, for
     * example as (20) XXXX XXXX, this field would be set to true. This will be
     * inherited from the value set for the territory in the XML file, unless a
     * national_prefix_optional_when_formatting is defined specifically for this
     * NumberFormat.
     * </pre>
     */
    boolean hasNationalPrefixOptionalWhenFormatting();
    /**
     * <code>optional bool national_prefix_optional_when_formatting = 6;</code>
     *
     * <pre>
     * This field specifies whether the $NP can be omitted when formatting a
     * number in national format, even though it usually wouldn't be. For example,
     * a UK number would be formatted by our library as 020 XXXX XXXX. If we have
     * commonly seen this number written by people without the leading 0, for
     * example as (20) XXXX XXXX, this field would be set to true. This will be
     * inherited from the value set for the territory in the XML file, unless a
     * national_prefix_optional_when_formatting is defined specifically for this
     * NumberFormat.
     * </pre>
     */
    boolean getNationalPrefixOptionalWhenFormatting();

    /**
     * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
     *
     * <pre>
     * This field specifies how any carrier code ($CC) together with the first
     * group ($FG) in the national significant number should be formatted
     * when formatWithCarrierCode is called, if carrier codes are used for a
     * certain country.
     * </pre>
     */
    boolean hasDomesticCarrierCodeFormattingRule();
    /**
     * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
     *
     * <pre>
     * This field specifies how any carrier code ($CC) together with the first
     * group ($FG) in the national significant number should be formatted
     * when formatWithCarrierCode is called, if carrier codes are used for a
     * certain country.
     * </pre>
     */
    java.lang.String getDomesticCarrierCodeFormattingRule();
    /**
     * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
     *
     * <pre>
     * This field specifies how any carrier code ($CC) together with the first
     * group ($FG) in the national significant number should be formatted
     * when formatWithCarrierCode is called, if carrier codes are used for a
     * certain country.
     * </pre>
     */
    com.google.protobuf.ByteString
        getDomesticCarrierCodeFormattingRuleBytes();
  }
  /**
   * Protobuf type {@code i18n.phonenumbers.NumberFormat}
   */
  public static final class NumberFormat extends
      com.google.protobuf.GeneratedMessageLite implements
      // @@protoc_insertion_point(message_implements:i18n.phonenumbers.NumberFormat)
      NumberFormatOrBuilder {
    // Use NumberFormat.newBuilder() to construct.
    private NumberFormat(com.google.protobuf.GeneratedMessageLite.Builder builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private NumberFormat(boolean noInit) { this.unknownFields = com.google.protobuf.ByteString.EMPTY;}

    private static final NumberFormat defaultInstance;
    public static NumberFormat getDefaultInstance() {
      return defaultInstance;
    }

    public NumberFormat getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.ByteString unknownFields;
    private NumberFormat(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.ByteString.Output unknownFieldsOutput =
          com.google.protobuf.ByteString.newOutput();
      com.google.protobuf.CodedOutputStream unknownFieldsCodedOutput =
          com.google.protobuf.CodedOutputStream.newInstance(
              unknownFieldsOutput);
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFieldsCodedOutput,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              pattern_ = bs;
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              format_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                leadingDigitsPattern_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              leadingDigitsPattern_.add(bs);
              break;
            }
            case 34: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              nationalPrefixFormattingRule_ = bs;
              break;
            }
            case 42: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000010;
              domesticCarrierCodeFormattingRule_ = bs;
              break;
            }
            case 48: {
              bitField0_ |= 0x00000008;
              nationalPrefixOptionalWhenFormatting_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          leadingDigitsPattern_ = leadingDigitsPattern_.getUnmodifiableView();
        }
        try {
          unknownFieldsCodedOutput.flush();
        } catch (java.io.IOException e) {
        // Should not happen
        } finally {
          unknownFields = unknownFieldsOutput.toByteString();
        }
        makeExtensionsImmutable();
      }
    }
    public static com.google.protobuf.Parser<NumberFormat> PARSER =
        new com.google.protobuf.AbstractParser<NumberFormat>() {
      public NumberFormat parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new NumberFormat(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<NumberFormat> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int PATTERN_FIELD_NUMBER = 1;
    private java.lang.Object pattern_;
    /**
     * <code>required string pattern = 1;</code>
     *
     * <pre>
     * pattern is a regex that is used to match the national (significant)
     * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
     * "2070313000", which is the national (significant) number for Google London.
     * Note the presence of the parentheses, which are capturing groups what
     * specifies the grouping of numbers.
     * </pre>
     */
    public boolean hasPattern() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>required string pattern = 1;</code>
     *
     * <pre>
     * pattern is a regex that is used to match the national (significant)
     * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
     * "2070313000", which is the national (significant) number for Google London.
     * Note the presence of the parentheses, which are capturing groups what
     * specifies the grouping of numbers.
     * </pre>
     */
    public java.lang.String getPattern() {
      java.lang.Object ref = pattern_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          pattern_ = s;
        }
        return s;
      }
    }
    /**
     * <code>required string pattern = 1;</code>
     *
     * <pre>
     * pattern is a regex that is used to match the national (significant)
     * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
     * "2070313000", which is the national (significant) number for Google London.
     * Note the presence of the parentheses, which are capturing groups what
     * specifies the grouping of numbers.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getPatternBytes() {
      java.lang.Object ref = pattern_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        pattern_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FORMAT_FIELD_NUMBER = 2;
    private java.lang.Object format_;
    /**
     * <code>required string format = 2;</code>
     *
     * <pre>
     * format specifies how the national (significant) number matched by
     * pattern should be formatted.
     * Using the same example as above, format could contain "$1 $2 $3",
     * meaning that the number should be formatted as "20 7031 3000".
     * Each $x are replaced by the numbers captured by group x in the
     * regex specified by pattern.
     * </pre>
     */
    public boolean hasFormat() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>required string format = 2;</code>
     *
     * <pre>
     * format specifies how the national (significant) number matched by
     * pattern should be formatted.
     * Using the same example as above, format could contain "$1 $2 $3",
     * meaning that the number should be formatted as "20 7031 3000".
     * Each $x are replaced by the numbers captured by group x in the
     * regex specified by pattern.
     * </pre>
     */
    public java.lang.String getFormat() {
      java.lang.Object ref = format_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          format_ = s;
        }
        return s;
      }
    }
    /**
     * <code>required string format = 2;</code>
     *
     * <pre>
     * format specifies how the national (significant) number matched by
     * pattern should be formatted.
     * Using the same example as above, format could contain "$1 $2 $3",
     * meaning that the number should be formatted as "20 7031 3000".
     * Each $x are replaced by the numbers captured by group x in the
     * regex specified by pattern.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getFormatBytes() {
      java.lang.Object ref = format_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        format_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LEADING_DIGITS_PATTERN_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList leadingDigitsPattern_;
    /**
     * <code>repeated string leading_digits_pattern = 3;</code>
     *
     * <pre>
     * This field is a regex that is used to match a certain number of digits
     * at the beginning of the national (significant) number. When the match is
     * successful, the accompanying pattern and format should be used to format
     * this number. For example, if leading_digits="[1-3]|44", then all the
     * national numbers starting with 1, 2, 3 or 44 should be formatted using the
     * accompanying pattern and format.
     * The first leadingDigitsPattern matches up to the first three digits of the
     * national (significant) number; the next one matches the first four digits,
     * then the first five and so on, until the leadingDigitsPattern can uniquely
     * identify one pattern and format to be used to format the number.
     * In the case when only one formatting pattern exists, no
     * leading_digits_pattern is needed.
     * </pre>
     */
    public com.google.protobuf.ProtocolStringList
        getLeadingDigitsPatternList() {
      return leadingDigitsPattern_;
    }
    /**
     * <code>repeated string leading_digits_pattern = 3;</code>
     *
     * <pre>
     * This field is a regex that is used to match a certain number of digits
     * at the beginning of the national (significant) number. When the match is
     * successful, the accompanying pattern and format should be used to format
     * this number. For example, if leading_digits="[1-3]|44", then all the
     * national numbers starting with 1, 2, 3 or 44 should be formatted using the
     * accompanying pattern and format.
     * The first leadingDigitsPattern matches up to the first three digits of the
     * national (significant) number; the next one matches the first four digits,
     * then the first five and so on, until the leadingDigitsPattern can uniquely
     * identify one pattern and format to be used to format the number.
     * In the case when only one formatting pattern exists, no
     * leading_digits_pattern is needed.
     * </pre>
     */
    public int getLeadingDigitsPatternCount() {
      return leadingDigitsPattern_.size();
    }
    /**
     * <code>repeated string leading_digits_pattern = 3;</code>
     *
     * <pre>
     * This field is a regex that is used to match a certain number of digits
     * at the beginning of the national (significant) number. When the match is
     * successful, the accompanying pattern and format should be used to format
     * this number. For example, if leading_digits="[1-3]|44", then all the
     * national numbers starting with 1, 2, 3 or 44 should be formatted using the
     * accompanying pattern and format.
     * The first leadingDigitsPattern matches up to the first three digits of the
     * national (significant) number; the next one matches the first four digits,
     * then the first five and so on, until the leadingDigitsPattern can uniquely
     * identify one pattern and format to be used to format the number.
     * In the case when only one formatting pattern exists, no
     * leading_digits_pattern is needed.
     * </pre>
     */
    public java.lang.String getLeadingDigitsPattern(int index) {
      return leadingDigitsPattern_.get(index);
    }
    /**
     * <code>repeated string leading_digits_pattern = 3;</code>
     *
     * <pre>
     * This field is a regex that is used to match a certain number of digits
     * at the beginning of the national (significant) number. When the match is
     * successful, the accompanying pattern and format should be used to format
     * this number. For example, if leading_digits="[1-3]|44", then all the
     * national numbers starting with 1, 2, 3 or 44 should be formatted using the
     * accompanying pattern and format.
     * The first leadingDigitsPattern matches up to the first three digits of the
     * national (significant) number; the next one matches the first four digits,
     * then the first five and so on, until the leadingDigitsPattern can uniquely
     * identify one pattern and format to be used to format the number.
     * In the case when only one formatting pattern exists, no
     * leading_digits_pattern is needed.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getLeadingDigitsPatternBytes(int index) {
      return leadingDigitsPattern_.getByteString(index);
    }

    public static final int NATIONAL_PREFIX_FORMATTING_RULE_FIELD_NUMBER = 4;
    private java.lang.Object nationalPrefixFormattingRule_;
    /**
     * <code>optional string national_prefix_formatting_rule = 4;</code>
     *
     * <pre>
     * This field specifies how the national prefix ($NP) together with the first
     * group ($FG) in the national significant number should be formatted in
     * the NATIONAL format when a national prefix exists for a certain country.
     * For example, when this field contains "($NP$FG)", a number from Beijing,
     * China (whose $NP = 0), which would by default be formatted without
     * national prefix as 10 1234 5678 in NATIONAL format, will instead be
     * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
     * would contain "($NP)$FG". Note $FG should always be present in this field,
     * but $NP can be omitted. For example, having "$FG" could indicate the
     * number should be formatted in NATIONAL format without the national prefix.
     * This is commonly used to override the rule specified for the territory in
     * the XML file.
     * When this field is missing, a number will be formatted without national
     * prefix in NATIONAL format. This field does not affect how a number
     * is formatted in other formats, such as INTERNATIONAL.
     * </pre>
     */
    public boolean hasNationalPrefixFormattingRule() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional string national_prefix_formatting_rule = 4;</code>
     *
     * <pre>
     * This field specifies how the national prefix ($NP) together with the first
     * group ($FG) in the national significant number should be formatted in
     * the NATIONAL format when a national prefix exists for a certain country.
     * For example, when this field contains "($NP$FG)", a number from Beijing,
     * China (whose $NP = 0), which would by default be formatted without
     * national prefix as 10 1234 5678 in NATIONAL format, will instead be
     * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
     * would contain "($NP)$FG". Note $FG should always be present in this field,
     * but $NP can be omitted. For example, having "$FG" could indicate the
     * number should be formatted in NATIONAL format without the national prefix.
     * This is commonly used to override the rule specified for the territory in
     * the XML file.
     * When this field is missing, a number will be formatted without national
     * prefix in NATIONAL format. This field does not affect how a number
     * is formatted in other formats, such as INTERNATIONAL.
     * </pre>
     */
    public java.lang.String getNationalPrefixFormattingRule() {
      java.lang.Object ref = nationalPrefixFormattingRule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          nationalPrefixFormattingRule_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string national_prefix_formatting_rule = 4;</code>
     *
     * <pre>
     * This field specifies how the national prefix ($NP) together with the first
     * group ($FG) in the national significant number should be formatted in
     * the NATIONAL format when a national prefix exists for a certain country.
     * For example, when this field contains "($NP$FG)", a number from Beijing,
     * China (whose $NP = 0), which would by default be formatted without
     * national prefix as 10 1234 5678 in NATIONAL format, will instead be
     * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
     * would contain "($NP)$FG". Note $FG should always be present in this field,
     * but $NP can be omitted. For example, having "$FG" could indicate the
     * number should be formatted in NATIONAL format without the national prefix.
     * This is commonly used to override the rule specified for the territory in
     * the XML file.
     * When this field is missing, a number will be formatted without national
     * prefix in NATIONAL format. This field does not affect how a number
     * is formatted in other formats, such as INTERNATIONAL.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getNationalPrefixFormattingRuleBytes() {
      java.lang.Object ref = nationalPrefixFormattingRule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nationalPrefixFormattingRule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NATIONAL_PREFIX_OPTIONAL_WHEN_FORMATTING_FIELD_NUMBER = 6;
    private boolean nationalPrefixOptionalWhenFormatting_;
    /**
     * <code>optional bool national_prefix_optional_when_formatting = 6;</code>
     *
     * <pre>
     * This field specifies whether the $NP can be omitted when formatting a
     * number in national format, even though it usually wouldn't be. For example,
     * a UK number would be formatted by our library as 020 XXXX XXXX. If we have
     * commonly seen this number written by people without the leading 0, for
     * example as (20) XXXX XXXX, this field would be set to true. This will be
     * inherited from the value set for the territory in the XML file, unless a
     * national_prefix_optional_when_formatting is defined specifically for this
     * NumberFormat.
     * </pre>
     */
    public boolean hasNationalPrefixOptionalWhenFormatting() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional bool national_prefix_optional_when_formatting = 6;</code>
     *
     * <pre>
     * This field specifies whether the $NP can be omitted when formatting a
     * number in national format, even though it usually wouldn't be. For example,
     * a UK number would be formatted by our library as 020 XXXX XXXX. If we have
     * commonly seen this number written by people without the leading 0, for
     * example as (20) XXXX XXXX, this field would be set to true. This will be
     * inherited from the value set for the territory in the XML file, unless a
     * national_prefix_optional_when_formatting is defined specifically for this
     * NumberFormat.
     * </pre>
     */
    public boolean getNationalPrefixOptionalWhenFormatting() {
      return nationalPrefixOptionalWhenFormatting_;
    }

    public static final int DOMESTIC_CARRIER_CODE_FORMATTING_RULE_FIELD_NUMBER = 5;
    private java.lang.Object domesticCarrierCodeFormattingRule_;
    /**
     * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
     *
     * <pre>
     * This field specifies how any carrier code ($CC) together with the first
     * group ($FG) in the national significant number should be formatted
     * when formatWithCarrierCode is called, if carrier codes are used for a
     * certain country.
     * </pre>
     */
    public boolean hasDomesticCarrierCodeFormattingRule() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
     *
     * <pre>
     * This field specifies how any carrier code ($CC) together with the first
     * group ($FG) in the national significant number should be formatted
     * when formatWithCarrierCode is called, if carrier codes are used for a
     * certain country.
     * </pre>
     */
    public java.lang.String getDomesticCarrierCodeFormattingRule() {
      java.lang.Object ref = domesticCarrierCodeFormattingRule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          domesticCarrierCodeFormattingRule_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
     *
     * <pre>
     * This field specifies how any carrier code ($CC) together with the first
     * group ($FG) in the national significant number should be formatted
     * when formatWithCarrierCode is called, if carrier codes are used for a
     * certain country.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getDomesticCarrierCodeFormattingRuleBytes() {
      java.lang.Object ref = domesticCarrierCodeFormattingRule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        domesticCarrierCodeFormattingRule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private void initFields() {
      pattern_ = "";
      format_ = "";
      leadingDigitsPattern_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      nationalPrefixFormattingRule_ = "";
      nationalPrefixOptionalWhenFormatting_ = false;
      domesticCarrierCodeFormattingRule_ = "";
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasPattern()) {
        memoizedIsInitialized = 0;
        return false;
      }
      if (!hasFormat()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(1, getPatternBytes());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(2, getFormatBytes());
      }
      for (int i = 0; i < leadingDigitsPattern_.size(); i++) {
        output.writeBytes(3, leadingDigitsPattern_.getByteString(i));
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(4, getNationalPrefixFormattingRuleBytes());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeBytes(5, getDomesticCarrierCodeFormattingRuleBytes());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeBool(6, nationalPrefixOptionalWhenFormatting_);
      }
      output.writeRawBytes(unknownFields);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, getPatternBytes());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, getFormatBytes());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < leadingDigitsPattern_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeBytesSizeNoTag(leadingDigitsPattern_.getByteString(i));
        }
        size += dataSize;
        size += 1 * getLeadingDigitsPatternList().size();
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, getNationalPrefixFormattingRuleBytes());
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(5, getDomesticCarrierCodeFormattingRuleBytes());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, nationalPrefixOptionalWhenFormatting_);
      }
      size += unknownFields.size();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(com.google.i18n.phonenumbers.Phonemetadata.NumberFormat prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    /**
     * Protobuf type {@code i18n.phonenumbers.NumberFormat}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.i18n.phonenumbers.Phonemetadata.NumberFormat, Builder>
        implements
        // @@protoc_insertion_point(builder_implements:i18n.phonenumbers.NumberFormat)
        com.google.i18n.phonenumbers.Phonemetadata.NumberFormatOrBuilder {
      // Construct using com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        pattern_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        format_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        leadingDigitsPattern_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        nationalPrefixFormattingRule_ = "";
        bitField0_ = (bitField0_ & ~0x00000008);
        nationalPrefixOptionalWhenFormatting_ = false;
        bitField0_ = (bitField0_ & ~0x00000010);
        domesticCarrierCodeFormattingRule_ = "";
        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.i18n.phonenumbers.Phonemetadata.NumberFormat getDefaultInstanceForType() {
        return com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.getDefaultInstance();
      }

      public com.google.i18n.phonenumbers.Phonemetadata.NumberFormat build() {
        com.google.i18n.phonenumbers.Phonemetadata.NumberFormat result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.i18n.phonenumbers.Phonemetadata.NumberFormat buildPartial() {
        com.google.i18n.phonenumbers.Phonemetadata.NumberFormat result = new com.google.i18n.phonenumbers.Phonemetadata.NumberFormat(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.pattern_ = pattern_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.format_ = format_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          leadingDigitsPattern_ = leadingDigitsPattern_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.leadingDigitsPattern_ = leadingDigitsPattern_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000004;
        }
        result.nationalPrefixFormattingRule_ = nationalPrefixFormattingRule_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000008;
        }
        result.nationalPrefixOptionalWhenFormatting_ = nationalPrefixOptionalWhenFormatting_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000010;
        }
        result.domesticCarrierCodeFormattingRule_ = domesticCarrierCodeFormattingRule_;
        result.bitField0_ = to_bitField0_;
        return result;
      }

      public Builder mergeFrom(com.google.i18n.phonenumbers.Phonemetadata.NumberFormat other) {
        if (other == com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.getDefaultInstance()) return this;
        if (other.hasPattern()) {
          bitField0_ |= 0x00000001;
          pattern_ = other.pattern_;
          
        }
        if (other.hasFormat()) {
          bitField0_ |= 0x00000002;
          format_ = other.format_;
          
        }
        if (!other.leadingDigitsPattern_.isEmpty()) {
          if (leadingDigitsPattern_.isEmpty()) {
            leadingDigitsPattern_ = other.leadingDigitsPattern_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureLeadingDigitsPatternIsMutable();
            leadingDigitsPattern_.addAll(other.leadingDigitsPattern_);
          }
          
        }
        if (other.hasNationalPrefixFormattingRule()) {
          bitField0_ |= 0x00000008;
          nationalPrefixFormattingRule_ = other.nationalPrefixFormattingRule_;
          
        }
        if (other.hasNationalPrefixOptionalWhenFormatting()) {
          setNationalPrefixOptionalWhenFormatting(other.getNationalPrefixOptionalWhenFormatting());
        }
        if (other.hasDomesticCarrierCodeFormattingRule()) {
          bitField0_ |= 0x00000020;
          domesticCarrierCodeFormattingRule_ = other.domesticCarrierCodeFormattingRule_;
          
        }
        setUnknownFields(
            getUnknownFields().concat(other.unknownFields));
        return this;
      }

      public final boolean isInitialized() {
        if (!hasPattern()) {
          
          return false;
        }
        if (!hasFormat()) {
          
          return false;
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.i18n.phonenumbers.Phonemetadata.NumberFormat parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.i18n.phonenumbers.Phonemetadata.NumberFormat) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object pattern_ = "";
      /**
       * <code>required string pattern = 1;</code>
       *
       * <pre>
       * pattern is a regex that is used to match the national (significant)
       * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
       * "2070313000", which is the national (significant) number for Google London.
       * Note the presence of the parentheses, which are capturing groups what
       * specifies the grouping of numbers.
       * </pre>
       */
      public boolean hasPattern() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>required string pattern = 1;</code>
       *
       * <pre>
       * pattern is a regex that is used to match the national (significant)
       * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
       * "2070313000", which is the national (significant) number for Google London.
       * Note the presence of the parentheses, which are capturing groups what
       * specifies the grouping of numbers.
       * </pre>
       */
      public java.lang.String getPattern() {
        java.lang.Object ref = pattern_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            pattern_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>required string pattern = 1;</code>
       *
       * <pre>
       * pattern is a regex that is used to match the national (significant)
       * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
       * "2070313000", which is the national (significant) number for Google London.
       * Note the presence of the parentheses, which are capturing groups what
       * specifies the grouping of numbers.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getPatternBytes() {
        java.lang.Object ref = pattern_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          pattern_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>required string pattern = 1;</code>
       *
       * <pre>
       * pattern is a regex that is used to match the national (significant)
       * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
       * "2070313000", which is the national (significant) number for Google London.
       * Note the presence of the parentheses, which are capturing groups what
       * specifies the grouping of numbers.
       * </pre>
       */
      public Builder setPattern(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        pattern_ = value;
        
        return this;
      }
      /**
       * <code>required string pattern = 1;</code>
       *
       * <pre>
       * pattern is a regex that is used to match the national (significant)
       * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
       * "2070313000", which is the national (significant) number for Google London.
       * Note the presence of the parentheses, which are capturing groups what
       * specifies the grouping of numbers.
       * </pre>
       */
      public Builder clearPattern() {
        bitField0_ = (bitField0_ & ~0x00000001);
        pattern_ = getDefaultInstance().getPattern();
        
        return this;
      }
      /**
       * <code>required string pattern = 1;</code>
       *
       * <pre>
       * pattern is a regex that is used to match the national (significant)
       * number. For example, the pattern "(20)(&#92;d{4})(&#92;d{4})" will match number
       * "2070313000", which is the national (significant) number for Google London.
       * Note the presence of the parentheses, which are capturing groups what
       * specifies the grouping of numbers.
       * </pre>
       */
      public Builder setPatternBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        pattern_ = value;
        
        return this;
      }

      private java.lang.Object format_ = "";
      /**
       * <code>required string format = 2;</code>
       *
       * <pre>
       * format specifies how the national (significant) number matched by
       * pattern should be formatted.
       * Using the same example as above, format could contain "$1 $2 $3",
       * meaning that the number should be formatted as "20 7031 3000".
       * Each $x are replaced by the numbers captured by group x in the
       * regex specified by pattern.
       * </pre>
       */
      public boolean hasFormat() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>required string format = 2;</code>
       *
       * <pre>
       * format specifies how the national (significant) number matched by
       * pattern should be formatted.
       * Using the same example as above, format could contain "$1 $2 $3",
       * meaning that the number should be formatted as "20 7031 3000".
       * Each $x are replaced by the numbers captured by group x in the
       * regex specified by pattern.
       * </pre>
       */
      public java.lang.String getFormat() {
        java.lang.Object ref = format_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            format_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>required string format = 2;</code>
       *
       * <pre>
       * format specifies how the national (significant) number matched by
       * pattern should be formatted.
       * Using the same example as above, format could contain "$1 $2 $3",
       * meaning that the number should be formatted as "20 7031 3000".
       * Each $x are replaced by the numbers captured by group x in the
       * regex specified by pattern.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getFormatBytes() {
        java.lang.Object ref = format_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          format_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>required string format = 2;</code>
       *
       * <pre>
       * format specifies how the national (significant) number matched by
       * pattern should be formatted.
       * Using the same example as above, format could contain "$1 $2 $3",
       * meaning that the number should be formatted as "20 7031 3000".
       * Each $x are replaced by the numbers captured by group x in the
       * regex specified by pattern.
       * </pre>
       */
      public Builder setFormat(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        format_ = value;
        
        return this;
      }
      /**
       * <code>required string format = 2;</code>
       *
       * <pre>
       * format specifies how the national (significant) number matched by
       * pattern should be formatted.
       * Using the same example as above, format could contain "$1 $2 $3",
       * meaning that the number should be formatted as "20 7031 3000".
       * Each $x are replaced by the numbers captured by group x in the
       * regex specified by pattern.
       * </pre>
       */
      public Builder clearFormat() {
        bitField0_ = (bitField0_ & ~0x00000002);
        format_ = getDefaultInstance().getFormat();
        
        return this;
      }
      /**
       * <code>required string format = 2;</code>
       *
       * <pre>
       * format specifies how the national (significant) number matched by
       * pattern should be formatted.
       * Using the same example as above, format could contain "$1 $2 $3",
       * meaning that the number should be formatted as "20 7031 3000".
       * Each $x are replaced by the numbers captured by group x in the
       * regex specified by pattern.
       * </pre>
       */
      public Builder setFormatBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        format_ = value;
        
        return this;
      }

      private com.google.protobuf.LazyStringList leadingDigitsPattern_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureLeadingDigitsPatternIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          leadingDigitsPattern_ = new com.google.protobuf.LazyStringArrayList(leadingDigitsPattern_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public com.google.protobuf.ProtocolStringList
          getLeadingDigitsPatternList() {
        return leadingDigitsPattern_.getUnmodifiableView();
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public int getLeadingDigitsPatternCount() {
        return leadingDigitsPattern_.size();
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public java.lang.String getLeadingDigitsPattern(int index) {
        return leadingDigitsPattern_.get(index);
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getLeadingDigitsPatternBytes(int index) {
        return leadingDigitsPattern_.getByteString(index);
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public Builder setLeadingDigitsPattern(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureLeadingDigitsPatternIsMutable();
        leadingDigitsPattern_.set(index, value);
        
        return this;
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public Builder addLeadingDigitsPattern(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureLeadingDigitsPatternIsMutable();
        leadingDigitsPattern_.add(value);
        
        return this;
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public Builder addAllLeadingDigitsPattern(
          java.lang.Iterable<java.lang.String> values) {
        ensureLeadingDigitsPatternIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, leadingDigitsPattern_);
        
        return this;
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public Builder clearLeadingDigitsPattern() {
        leadingDigitsPattern_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        
        return this;
      }
      /**
       * <code>repeated string leading_digits_pattern = 3;</code>
       *
       * <pre>
       * This field is a regex that is used to match a certain number of digits
       * at the beginning of the national (significant) number. When the match is
       * successful, the accompanying pattern and format should be used to format
       * this number. For example, if leading_digits="[1-3]|44", then all the
       * national numbers starting with 1, 2, 3 or 44 should be formatted using the
       * accompanying pattern and format.
       * The first leadingDigitsPattern matches up to the first three digits of the
       * national (significant) number; the next one matches the first four digits,
       * then the first five and so on, until the leadingDigitsPattern can uniquely
       * identify one pattern and format to be used to format the number.
       * In the case when only one formatting pattern exists, no
       * leading_digits_pattern is needed.
       * </pre>
       */
      public Builder addLeadingDigitsPatternBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureLeadingDigitsPatternIsMutable();
        leadingDigitsPattern_.add(value);
        
        return this;
      }

      private java.lang.Object nationalPrefixFormattingRule_ = "";
      /**
       * <code>optional string national_prefix_formatting_rule = 4;</code>
       *
       * <pre>
       * This field specifies how the national prefix ($NP) together with the first
       * group ($FG) in the national significant number should be formatted in
       * the NATIONAL format when a national prefix exists for a certain country.
       * For example, when this field contains "($NP$FG)", a number from Beijing,
       * China (whose $NP = 0), which would by default be formatted without
       * national prefix as 10 1234 5678 in NATIONAL format, will instead be
       * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
       * would contain "($NP)$FG". Note $FG should always be present in this field,
       * but $NP can be omitted. For example, having "$FG" could indicate the
       * number should be formatted in NATIONAL format without the national prefix.
       * This is commonly used to override the rule specified for the territory in
       * the XML file.
       * When this field is missing, a number will be formatted without national
       * prefix in NATIONAL format. This field does not affect how a number
       * is formatted in other formats, such as INTERNATIONAL.
       * </pre>
       */
      public boolean hasNationalPrefixFormattingRule() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional string national_prefix_formatting_rule = 4;</code>
       *
       * <pre>
       * This field specifies how the national prefix ($NP) together with the first
       * group ($FG) in the national significant number should be formatted in
       * the NATIONAL format when a national prefix exists for a certain country.
       * For example, when this field contains "($NP$FG)", a number from Beijing,
       * China (whose $NP = 0), which would by default be formatted without
       * national prefix as 10 1234 5678 in NATIONAL format, will instead be
       * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
       * would contain "($NP)$FG". Note $FG should always be present in this field,
       * but $NP can be omitted. For example, having "$FG" could indicate the
       * number should be formatted in NATIONAL format without the national prefix.
       * This is commonly used to override the rule specified for the territory in
       * the XML file.
       * When this field is missing, a number will be formatted without national
       * prefix in NATIONAL format. This field does not affect how a number
       * is formatted in other formats, such as INTERNATIONAL.
       * </pre>
       */
      public java.lang.String getNationalPrefixFormattingRule() {
        java.lang.Object ref = nationalPrefixFormattingRule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            nationalPrefixFormattingRule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string national_prefix_formatting_rule = 4;</code>
       *
       * <pre>
       * This field specifies how the national prefix ($NP) together with the first
       * group ($FG) in the national significant number should be formatted in
       * the NATIONAL format when a national prefix exists for a certain country.
       * For example, when this field contains "($NP$FG)", a number from Beijing,
       * China (whose $NP = 0), which would by default be formatted without
       * national prefix as 10 1234 5678 in NATIONAL format, will instead be
       * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
       * would contain "($NP)$FG". Note $FG should always be present in this field,
       * but $NP can be omitted. For example, having "$FG" could indicate the
       * number should be formatted in NATIONAL format without the national prefix.
       * This is commonly used to override the rule specified for the territory in
       * the XML file.
       * When this field is missing, a number will be formatted without national
       * prefix in NATIONAL format. This field does not affect how a number
       * is formatted in other formats, such as INTERNATIONAL.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getNationalPrefixFormattingRuleBytes() {
        java.lang.Object ref = nationalPrefixFormattingRule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nationalPrefixFormattingRule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string national_prefix_formatting_rule = 4;</code>
       *
       * <pre>
       * This field specifies how the national prefix ($NP) together with the first
       * group ($FG) in the national significant number should be formatted in
       * the NATIONAL format when a national prefix exists for a certain country.
       * For example, when this field contains "($NP$FG)", a number from Beijing,
       * China (whose $NP = 0), which would by default be formatted without
       * national prefix as 10 1234 5678 in NATIONAL format, will instead be
       * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
       * would contain "($NP)$FG". Note $FG should always be present in this field,
       * but $NP can be omitted. For example, having "$FG" could indicate the
       * number should be formatted in NATIONAL format without the national prefix.
       * This is commonly used to override the rule specified for the territory in
       * the XML file.
       * When this field is missing, a number will be formatted without national
       * prefix in NATIONAL format. This field does not affect how a number
       * is formatted in other formats, such as INTERNATIONAL.
       * </pre>
       */
      public Builder setNationalPrefixFormattingRule(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        nationalPrefixFormattingRule_ = value;
        
        return this;
      }
      /**
       * <code>optional string national_prefix_formatting_rule = 4;</code>
       *
       * <pre>
       * This field specifies how the national prefix ($NP) together with the first
       * group ($FG) in the national significant number should be formatted in
       * the NATIONAL format when a national prefix exists for a certain country.
       * For example, when this field contains "($NP$FG)", a number from Beijing,
       * China (whose $NP = 0), which would by default be formatted without
       * national prefix as 10 1234 5678 in NATIONAL format, will instead be
       * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
       * would contain "($NP)$FG". Note $FG should always be present in this field,
       * but $NP can be omitted. For example, having "$FG" could indicate the
       * number should be formatted in NATIONAL format without the national prefix.
       * This is commonly used to override the rule specified for the territory in
       * the XML file.
       * When this field is missing, a number will be formatted without national
       * prefix in NATIONAL format. This field does not affect how a number
       * is formatted in other formats, such as INTERNATIONAL.
       * </pre>
       */
      public Builder clearNationalPrefixFormattingRule() {
        bitField0_ = (bitField0_ & ~0x00000008);
        nationalPrefixFormattingRule_ = getDefaultInstance().getNationalPrefixFormattingRule();
        
        return this;
      }
      /**
       * <code>optional string national_prefix_formatting_rule = 4;</code>
       *
       * <pre>
       * This field specifies how the national prefix ($NP) together with the first
       * group ($FG) in the national significant number should be formatted in
       * the NATIONAL format when a national prefix exists for a certain country.
       * For example, when this field contains "($NP$FG)", a number from Beijing,
       * China (whose $NP = 0), which would by default be formatted without
       * national prefix as 10 1234 5678 in NATIONAL format, will instead be
       * formatted as (010) 1234 5678; to format it as (0)10 1234 5678, the field
       * would contain "($NP)$FG". Note $FG should always be present in this field,
       * but $NP can be omitted. For example, having "$FG" could indicate the
       * number should be formatted in NATIONAL format without the national prefix.
       * This is commonly used to override the rule specified for the territory in
       * the XML file.
       * When this field is missing, a number will be formatted without national
       * prefix in NATIONAL format. This field does not affect how a number
       * is formatted in other formats, such as INTERNATIONAL.
       * </pre>
       */
      public Builder setNationalPrefixFormattingRuleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        nationalPrefixFormattingRule_ = value;
        
        return this;
      }

      private boolean nationalPrefixOptionalWhenFormatting_ ;
      /**
       * <code>optional bool national_prefix_optional_when_formatting = 6;</code>
       *
       * <pre>
       * This field specifies whether the $NP can be omitted when formatting a
       * number in national format, even though it usually wouldn't be. For example,
       * a UK number would be formatted by our library as 020 XXXX XXXX. If we have
       * commonly seen this number written by people without the leading 0, for
       * example as (20) XXXX XXXX, this field would be set to true. This will be
       * inherited from the value set for the territory in the XML file, unless a
       * national_prefix_optional_when_formatting is defined specifically for this
       * NumberFormat.
       * </pre>
       */
      public boolean hasNationalPrefixOptionalWhenFormatting() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional bool national_prefix_optional_when_formatting = 6;</code>
       *
       * <pre>
       * This field specifies whether the $NP can be omitted when formatting a
       * number in national format, even though it usually wouldn't be. For example,
       * a UK number would be formatted by our library as 020 XXXX XXXX. If we have
       * commonly seen this number written by people without the leading 0, for
       * example as (20) XXXX XXXX, this field would be set to true. This will be
       * inherited from the value set for the territory in the XML file, unless a
       * national_prefix_optional_when_formatting is defined specifically for this
       * NumberFormat.
       * </pre>
       */
      public boolean getNationalPrefixOptionalWhenFormatting() {
        return nationalPrefixOptionalWhenFormatting_;
      }
      /**
       * <code>optional bool national_prefix_optional_when_formatting = 6;</code>
       *
       * <pre>
       * This field specifies whether the $NP can be omitted when formatting a
       * number in national format, even though it usually wouldn't be. For example,
       * a UK number would be formatted by our library as 020 XXXX XXXX. If we have
       * commonly seen this number written by people without the leading 0, for
       * example as (20) XXXX XXXX, this field would be set to true. This will be
       * inherited from the value set for the territory in the XML file, unless a
       * national_prefix_optional_when_formatting is defined specifically for this
       * NumberFormat.
       * </pre>
       */
      public Builder setNationalPrefixOptionalWhenFormatting(boolean value) {
        bitField0_ |= 0x00000010;
        nationalPrefixOptionalWhenFormatting_ = value;
        
        return this;
      }
      /**
       * <code>optional bool national_prefix_optional_when_formatting = 6;</code>
       *
       * <pre>
       * This field specifies whether the $NP can be omitted when formatting a
       * number in national format, even though it usually wouldn't be. For example,
       * a UK number would be formatted by our library as 020 XXXX XXXX. If we have
       * commonly seen this number written by people without the leading 0, for
       * example as (20) XXXX XXXX, this field would be set to true. This will be
       * inherited from the value set for the territory in the XML file, unless a
       * national_prefix_optional_when_formatting is defined specifically for this
       * NumberFormat.
       * </pre>
       */
      public Builder clearNationalPrefixOptionalWhenFormatting() {
        bitField0_ = (bitField0_ & ~0x00000010);
        nationalPrefixOptionalWhenFormatting_ = false;
        
        return this;
      }

      private java.lang.Object domesticCarrierCodeFormattingRule_ = "";
      /**
       * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
       *
       * <pre>
       * This field specifies how any carrier code ($CC) together with the first
       * group ($FG) in the national significant number should be formatted
       * when formatWithCarrierCode is called, if carrier codes are used for a
       * certain country.
       * </pre>
       */
      public boolean hasDomesticCarrierCodeFormattingRule() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
       *
       * <pre>
       * This field specifies how any carrier code ($CC) together with the first
       * group ($FG) in the national significant number should be formatted
       * when formatWithCarrierCode is called, if carrier codes are used for a
       * certain country.
       * </pre>
       */
      public java.lang.String getDomesticCarrierCodeFormattingRule() {
        java.lang.Object ref = domesticCarrierCodeFormattingRule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            domesticCarrierCodeFormattingRule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
       *
       * <pre>
       * This field specifies how any carrier code ($CC) together with the first
       * group ($FG) in the national significant number should be formatted
       * when formatWithCarrierCode is called, if carrier codes are used for a
       * certain country.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getDomesticCarrierCodeFormattingRuleBytes() {
        java.lang.Object ref = domesticCarrierCodeFormattingRule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          domesticCarrierCodeFormattingRule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
       *
       * <pre>
       * This field specifies how any carrier code ($CC) together with the first
       * group ($FG) in the national significant number should be formatted
       * when formatWithCarrierCode is called, if carrier codes are used for a
       * certain country.
       * </pre>
       */
      public Builder setDomesticCarrierCodeFormattingRule(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        domesticCarrierCodeFormattingRule_ = value;
        
        return this;
      }
      /**
       * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
       *
       * <pre>
       * This field specifies how any carrier code ($CC) together with the first
       * group ($FG) in the national significant number should be formatted
       * when formatWithCarrierCode is called, if carrier codes are used for a
       * certain country.
       * </pre>
       */
      public Builder clearDomesticCarrierCodeFormattingRule() {
        bitField0_ = (bitField0_ & ~0x00000020);
        domesticCarrierCodeFormattingRule_ = getDefaultInstance().getDomesticCarrierCodeFormattingRule();
        
        return this;
      }
      /**
       * <code>optional string domestic_carrier_code_formatting_rule = 5;</code>
       *
       * <pre>
       * This field specifies how any carrier code ($CC) together with the first
       * group ($FG) in the national significant number should be formatted
       * when formatWithCarrierCode is called, if carrier codes are used for a
       * certain country.
       * </pre>
       */
      public Builder setDomesticCarrierCodeFormattingRuleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000020;
        domesticCarrierCodeFormattingRule_ = value;
        
        return this;
      }

      // @@protoc_insertion_point(builder_scope:i18n.phonenumbers.NumberFormat)
    }

    static {
      defaultInstance = new NumberFormat(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:i18n.phonenumbers.NumberFormat)
  }

  public interface PhoneNumberDescOrBuilder extends
      // @@protoc_insertion_point(interface_extends:i18n.phonenumbers.PhoneNumberDesc)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional string national_number_pattern = 2;</code>
     *
     * <pre>
     * The national_number_pattern is the pattern that a valid national
     * significant number would match. This specifies information such as its
     * total length and leading digits.
     * </pre>
     */
    boolean hasNationalNumberPattern();
    /**
     * <code>optional string national_number_pattern = 2;</code>
     *
     * <pre>
     * The national_number_pattern is the pattern that a valid national
     * significant number would match. This specifies information such as its
     * total length and leading digits.
     * </pre>
     */
    java.lang.String getNationalNumberPattern();
    /**
     * <code>optional string national_number_pattern = 2;</code>
     *
     * <pre>
     * The national_number_pattern is the pattern that a valid national
     * significant number would match. This specifies information such as its
     * total length and leading digits.
     * </pre>
     */
    com.google.protobuf.ByteString
        getNationalNumberPatternBytes();

    /**
     * <code>optional string possible_number_pattern = 3;</code>
     *
     * <pre>
     * The possible_number_pattern represents what a potentially valid phone
     * number for this region may be written as. This is a superset of the
     * national_number_pattern above and includes numbers that have the area code
     * omitted. Typically the only restrictions here are in the number of digits.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    boolean hasPossibleNumberPattern();
    /**
     * <code>optional string possible_number_pattern = 3;</code>
     *
     * <pre>
     * The possible_number_pattern represents what a potentially valid phone
     * number for this region may be written as. This is a superset of the
     * national_number_pattern above and includes numbers that have the area code
     * omitted. Typically the only restrictions here are in the number of digits.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    java.lang.String getPossibleNumberPattern();
    /**
     * <code>optional string possible_number_pattern = 3;</code>
     *
     * <pre>
     * The possible_number_pattern represents what a potentially valid phone
     * number for this region may be written as. This is a superset of the
     * national_number_pattern above and includes numbers that have the area code
     * omitted. Typically the only restrictions here are in the number of digits.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    com.google.protobuf.ByteString
        getPossibleNumberPatternBytes();

    /**
     * <code>repeated int32 possible_length = 9;</code>
     *
     * <pre>
     * These represent the lengths a phone number from this region can be. They
     * will be sorted from smallest to biggest. Note that these lengths are for
     * the full number, without country calling code or national prefix. For
     * example, for the Swiss number +41789270000, in local format 0789270000,
     * this would be 9.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    java.util.List<java.lang.Integer> getPossibleLengthList();
    /**
     * <code>repeated int32 possible_length = 9;</code>
     *
     * <pre>
     * These represent the lengths a phone number from this region can be. They
     * will be sorted from smallest to biggest. Note that these lengths are for
     * the full number, without country calling code or national prefix. For
     * example, for the Swiss number +41789270000, in local format 0789270000,
     * this would be 9.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    int getPossibleLengthCount();
    /**
     * <code>repeated int32 possible_length = 9;</code>
     *
     * <pre>
     * These represent the lengths a phone number from this region can be. They
     * will be sorted from smallest to biggest. Note that these lengths are for
     * the full number, without country calling code or national prefix. For
     * example, for the Swiss number +41789270000, in local format 0789270000,
     * this would be 9.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    int getPossibleLength(int index);

    /**
     * <code>repeated int32 possible_length_local_only = 10;</code>
     *
     * <pre>
     * These represent the lengths that only local phone numbers (without an area
     * code) from this region can be. They will be sorted from smallest to
     * biggest. For example, since the American number 456-1234 may be locally
     * diallable, although not diallable from outside the area, 7 could be a
     * possible value.
     * This could be used to highlight tokens in a text that may be a phone
     * number.
     * To our knowledge, area codes are usually only relevant for some fixed-line
     * and mobile numbers, so this field should only be set for those types of
     * numbers (and the general description) - however there are exceptions for
     * NANPA countries.
     * </pre>
     */
    java.util.List<java.lang.Integer> getPossibleLengthLocalOnlyList();
    /**
     * <code>repeated int32 possible_length_local_only = 10;</code>
     *
     * <pre>
     * These represent the lengths that only local phone numbers (without an area
     * code) from this region can be. They will be sorted from smallest to
     * biggest. For example, since the American number 456-1234 may be locally
     * diallable, although not diallable from outside the area, 7 could be a
     * possible value.
     * This could be used to highlight tokens in a text that may be a phone
     * number.
     * To our knowledge, area codes are usually only relevant for some fixed-line
     * and mobile numbers, so this field should only be set for those types of
     * numbers (and the general description) - however there are exceptions for
     * NANPA countries.
     * </pre>
     */
    int getPossibleLengthLocalOnlyCount();
    /**
     * <code>repeated int32 possible_length_local_only = 10;</code>
     *
     * <pre>
     * These represent the lengths that only local phone numbers (without an area
     * code) from this region can be. They will be sorted from smallest to
     * biggest. For example, since the American number 456-1234 may be locally
     * diallable, although not diallable from outside the area, 7 could be a
     * possible value.
     * This could be used to highlight tokens in a text that may be a phone
     * number.
     * To our knowledge, area codes are usually only relevant for some fixed-line
     * and mobile numbers, so this field should only be set for those types of
     * numbers (and the general description) - however there are exceptions for
     * NANPA countries.
     * </pre>
     */
    int getPossibleLengthLocalOnly(int index);

    /**
     * <code>optional string example_number = 6;</code>
     *
     * <pre>
     * An example national significant number for the specific type. It should
     * not contain any formatting information.
     * </pre>
     */
    boolean hasExampleNumber();
    /**
     * <code>optional string example_number = 6;</code>
     *
     * <pre>
     * An example national significant number for the specific type. It should
     * not contain any formatting information.
     * </pre>
     */
    java.lang.String getExampleNumber();
    /**
     * <code>optional string example_number = 6;</code>
     *
     * <pre>
     * An example national significant number for the specific type. It should
     * not contain any formatting information.
     * </pre>
     */
    com.google.protobuf.ByteString
        getExampleNumberBytes();
  }
  /**
   * Protobuf type {@code i18n.phonenumbers.PhoneNumberDesc}
   *
   * <pre>
   * If you add, remove, or rename fields, or change their semantics, check if you
   * should change the excludable field sets or the behavior in MetadataFilter.
   * </pre>
   */
  public static final class PhoneNumberDesc extends
      com.google.protobuf.GeneratedMessageLite implements
      // @@protoc_insertion_point(message_implements:i18n.phonenumbers.PhoneNumberDesc)
      PhoneNumberDescOrBuilder {
    // Use PhoneNumberDesc.newBuilder() to construct.
    private PhoneNumberDesc(com.google.protobuf.GeneratedMessageLite.Builder builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private PhoneNumberDesc(boolean noInit) { this.unknownFields = com.google.protobuf.ByteString.EMPTY;}

    private static final PhoneNumberDesc defaultInstance;
    public static PhoneNumberDesc getDefaultInstance() {
      return defaultInstance;
    }

    public PhoneNumberDesc getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.ByteString unknownFields;
    private PhoneNumberDesc(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.ByteString.Output unknownFieldsOutput =
          com.google.protobuf.ByteString.newOutput();
      com.google.protobuf.CodedOutputStream unknownFieldsCodedOutput =
          com.google.protobuf.CodedOutputStream.newInstance(
              unknownFieldsOutput);
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFieldsCodedOutput,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 18: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              nationalNumberPattern_ = bs;
              break;
            }
            case 26: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000002;
              possibleNumberPattern_ = bs;
              break;
            }
            case 50: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000004;
              exampleNumber_ = bs;
              break;
            }
            case 72: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                possibleLength_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000004;
              }
              possibleLength_.add(input.readInt32());
              break;
            }
            case 74: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004) && input.getBytesUntilLimit() > 0) {
                possibleLength_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000004;
              }
              while (input.getBytesUntilLimit() > 0) {
                possibleLength_.add(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
            case 80: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                possibleLengthLocalOnly_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000008;
              }
              possibleLengthLocalOnly_.add(input.readInt32());
              break;
            }
            case 82: {
              int length = input.readRawVarint32();
              int limit = input.pushLimit(length);
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008) && input.getBytesUntilLimit() > 0) {
                possibleLengthLocalOnly_ = new java.util.ArrayList<java.lang.Integer>();
                mutable_bitField0_ |= 0x00000008;
              }
              while (input.getBytesUntilLimit() > 0) {
                possibleLengthLocalOnly_.add(input.readInt32());
              }
              input.popLimit(limit);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          possibleLength_ = java.util.Collections.unmodifiableList(possibleLength_);
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          possibleLengthLocalOnly_ = java.util.Collections.unmodifiableList(possibleLengthLocalOnly_);
        }
        try {
          unknownFieldsCodedOutput.flush();
        } catch (java.io.IOException e) {
        // Should not happen
        } finally {
          unknownFields = unknownFieldsOutput.toByteString();
        }
        makeExtensionsImmutable();
      }
    }
    public static com.google.protobuf.Parser<PhoneNumberDesc> PARSER =
        new com.google.protobuf.AbstractParser<PhoneNumberDesc>() {
      public PhoneNumberDesc parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PhoneNumberDesc(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<PhoneNumberDesc> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int NATIONAL_NUMBER_PATTERN_FIELD_NUMBER = 2;
    private java.lang.Object nationalNumberPattern_;
    /**
     * <code>optional string national_number_pattern = 2;</code>
     *
     * <pre>
     * The national_number_pattern is the pattern that a valid national
     * significant number would match. This specifies information such as its
     * total length and leading digits.
     * </pre>
     */
    public boolean hasNationalNumberPattern() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional string national_number_pattern = 2;</code>
     *
     * <pre>
     * The national_number_pattern is the pattern that a valid national
     * significant number would match. This specifies information such as its
     * total length and leading digits.
     * </pre>
     */
    public java.lang.String getNationalNumberPattern() {
      java.lang.Object ref = nationalNumberPattern_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          nationalNumberPattern_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string national_number_pattern = 2;</code>
     *
     * <pre>
     * The national_number_pattern is the pattern that a valid national
     * significant number would match. This specifies information such as its
     * total length and leading digits.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getNationalNumberPatternBytes() {
      java.lang.Object ref = nationalNumberPattern_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nationalNumberPattern_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int POSSIBLE_NUMBER_PATTERN_FIELD_NUMBER = 3;
    private java.lang.Object possibleNumberPattern_;
    /**
     * <code>optional string possible_number_pattern = 3;</code>
     *
     * <pre>
     * The possible_number_pattern represents what a potentially valid phone
     * number for this region may be written as. This is a superset of the
     * national_number_pattern above and includes numbers that have the area code
     * omitted. Typically the only restrictions here are in the number of digits.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    public boolean hasPossibleNumberPattern() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional string possible_number_pattern = 3;</code>
     *
     * <pre>
     * The possible_number_pattern represents what a potentially valid phone
     * number for this region may be written as. This is a superset of the
     * national_number_pattern above and includes numbers that have the area code
     * omitted. Typically the only restrictions here are in the number of digits.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    public java.lang.String getPossibleNumberPattern() {
      java.lang.Object ref = possibleNumberPattern_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          possibleNumberPattern_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string possible_number_pattern = 3;</code>
     *
     * <pre>
     * The possible_number_pattern represents what a potentially valid phone
     * number for this region may be written as. This is a superset of the
     * national_number_pattern above and includes numbers that have the area code
     * omitted. Typically the only restrictions here are in the number of digits.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getPossibleNumberPatternBytes() {
      java.lang.Object ref = possibleNumberPattern_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        possibleNumberPattern_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int POSSIBLE_LENGTH_FIELD_NUMBER = 9;
    private java.util.List<java.lang.Integer> possibleLength_;
    /**
     * <code>repeated int32 possible_length = 9;</code>
     *
     * <pre>
     * These represent the lengths a phone number from this region can be. They
     * will be sorted from smallest to biggest. Note that these lengths are for
     * the full number, without country calling code or national prefix. For
     * example, for the Swiss number +41789270000, in local format 0789270000,
     * this would be 9.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    public java.util.List<java.lang.Integer>
        getPossibleLengthList() {
      return possibleLength_;
    }
    /**
     * <code>repeated int32 possible_length = 9;</code>
     *
     * <pre>
     * These represent the lengths a phone number from this region can be. They
     * will be sorted from smallest to biggest. Note that these lengths are for
     * the full number, without country calling code or national prefix. For
     * example, for the Swiss number +41789270000, in local format 0789270000,
     * this would be 9.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    public int getPossibleLengthCount() {
      return possibleLength_.size();
    }
    /**
     * <code>repeated int32 possible_length = 9;</code>
     *
     * <pre>
     * These represent the lengths a phone number from this region can be. They
     * will be sorted from smallest to biggest. Note that these lengths are for
     * the full number, without country calling code or national prefix. For
     * example, for the Swiss number +41789270000, in local format 0789270000,
     * this would be 9.
     * This could be used to highlight tokens in a text that may be a phone
     * number, or to quickly prune numbers that could not possibly be a phone
     * number for this locale.
     * </pre>
     */
    public int getPossibleLength(int index) {
      return possibleLength_.get(index);
    }

    public static final int POSSIBLE_LENGTH_LOCAL_ONLY_FIELD_NUMBER = 10;
    private java.util.List<java.lang.Integer> possibleLengthLocalOnly_;
    /**
     * <code>repeated int32 possible_length_local_only = 10;</code>
     *
     * <pre>
     * These represent the lengths that only local phone numbers (without an area
     * code) from this region can be. They will be sorted from smallest to
     * biggest. For example, since the American number 456-1234 may be locally
     * diallable, although not diallable from outside the area, 7 could be a
     * possible value.
     * This could be used to highlight tokens in a text that may be a phone
     * number.
     * To our knowledge, area codes are usually only relevant for some fixed-line
     * and mobile numbers, so this field should only be set for those types of
     * numbers (and the general description) - however there are exceptions for
     * NANPA countries.
     * </pre>
     */
    public java.util.List<java.lang.Integer>
        getPossibleLengthLocalOnlyList() {
      return possibleLengthLocalOnly_;
    }
    /**
     * <code>repeated int32 possible_length_local_only = 10;</code>
     *
     * <pre>
     * These represent the lengths that only local phone numbers (without an area
     * code) from this region can be. They will be sorted from smallest to
     * biggest. For example, since the American number 456-1234 may be locally
     * diallable, although not diallable from outside the area, 7 could be a
     * possible value.
     * This could be used to highlight tokens in a text that may be a phone
     * number.
     * To our knowledge, area codes are usually only relevant for some fixed-line
     * and mobile numbers, so this field should only be set for those types of
     * numbers (and the general description) - however there are exceptions for
     * NANPA countries.
     * </pre>
     */
    public int getPossibleLengthLocalOnlyCount() {
      return possibleLengthLocalOnly_.size();
    }
    /**
     * <code>repeated int32 possible_length_local_only = 10;</code>
     *
     * <pre>
     * These represent the lengths that only local phone numbers (without an area
     * code) from this region can be. They will be sorted from smallest to
     * biggest. For example, since the American number 456-1234 may be locally
     * diallable, although not diallable from outside the area, 7 could be a
     * possible value.
     * This could be used to highlight tokens in a text that may be a phone
     * number.
     * To our knowledge, area codes are usually only relevant for some fixed-line
     * and mobile numbers, so this field should only be set for those types of
     * numbers (and the general description) - however there are exceptions for
     * NANPA countries.
     * </pre>
     */
    public int getPossibleLengthLocalOnly(int index) {
      return possibleLengthLocalOnly_.get(index);
    }

    public static final int EXAMPLE_NUMBER_FIELD_NUMBER = 6;
    private java.lang.Object exampleNumber_;
    /**
     * <code>optional string example_number = 6;</code>
     *
     * <pre>
     * An example national significant number for the specific type. It should
     * not contain any formatting information.
     * </pre>
     */
    public boolean hasExampleNumber() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional string example_number = 6;</code>
     *
     * <pre>
     * An example national significant number for the specific type. It should
     * not contain any formatting information.
     * </pre>
     */
    public java.lang.String getExampleNumber() {
      java.lang.Object ref = exampleNumber_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          exampleNumber_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string example_number = 6;</code>
     *
     * <pre>
     * An example national significant number for the specific type. It should
     * not contain any formatting information.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getExampleNumberBytes() {
      java.lang.Object ref = exampleNumber_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        exampleNumber_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private void initFields() {
      nationalNumberPattern_ = "";
      possibleNumberPattern_ = "";
      possibleLength_ = java.util.Collections.emptyList();
      possibleLengthLocalOnly_ = java.util.Collections.emptyList();
      exampleNumber_ = "";
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeBytes(2, getNationalNumberPatternBytes());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeBytes(3, getPossibleNumberPatternBytes());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeBytes(6, getExampleNumberBytes());
      }
      for (int i = 0; i < possibleLength_.size(); i++) {
        output.writeInt32(9, possibleLength_.get(i));
      }
      for (int i = 0; i < possibleLengthLocalOnly_.size(); i++) {
        output.writeInt32(10, possibleLengthLocalOnly_.get(i));
      }
      output.writeRawBytes(unknownFields);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, getNationalNumberPatternBytes());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, getPossibleNumberPatternBytes());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(6, getExampleNumberBytes());
      }
      {
        int dataSize = 0;
        for (int i = 0; i < possibleLength_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(possibleLength_.get(i));
        }
        size += dataSize;
        size += 1 * getPossibleLengthList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < possibleLengthLocalOnly_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(possibleLengthLocalOnly_.get(i));
        }
        size += dataSize;
        size += 1 * getPossibleLengthLocalOnlyList().size();
      }
      size += unknownFields.size();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    /**
     * Protobuf type {@code i18n.phonenumbers.PhoneNumberDesc}
     *
     * <pre>
     * If you add, remove, or rename fields, or change their semantics, check if you
     * should change the excludable field sets or the behavior in MetadataFilter.
     * </pre>
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc, Builder>
        implements
        // @@protoc_insertion_point(builder_implements:i18n.phonenumbers.PhoneNumberDesc)
        com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDescOrBuilder {
      // Construct using com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        nationalNumberPattern_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        possibleNumberPattern_ = "";
        bitField0_ = (bitField0_ & ~0x00000002);
        possibleLength_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        possibleLengthLocalOnly_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        exampleNumber_ = "";
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getDefaultInstanceForType() {
        return com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc build() {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc buildPartial() {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc result = new com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.nationalNumberPattern_ = nationalNumberPattern_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.possibleNumberPattern_ = possibleNumberPattern_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          possibleLength_ = java.util.Collections.unmodifiableList(possibleLength_);
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.possibleLength_ = possibleLength_;
        if (((bitField0_ & 0x00000008) == 0x00000008)) {
          possibleLengthLocalOnly_ = java.util.Collections.unmodifiableList(possibleLengthLocalOnly_);
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.possibleLengthLocalOnly_ = possibleLengthLocalOnly_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000004;
        }
        result.exampleNumber_ = exampleNumber_;
        result.bitField0_ = to_bitField0_;
        return result;
      }

      public Builder mergeFrom(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc other) {
        if (other == com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) return this;
        if (other.hasNationalNumberPattern()) {
          bitField0_ |= 0x00000001;
          nationalNumberPattern_ = other.nationalNumberPattern_;
          
        }
        if (other.hasPossibleNumberPattern()) {
          bitField0_ |= 0x00000002;
          possibleNumberPattern_ = other.possibleNumberPattern_;
          
        }
        if (!other.possibleLength_.isEmpty()) {
          if (possibleLength_.isEmpty()) {
            possibleLength_ = other.possibleLength_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensurePossibleLengthIsMutable();
            possibleLength_.addAll(other.possibleLength_);
          }
          
        }
        if (!other.possibleLengthLocalOnly_.isEmpty()) {
          if (possibleLengthLocalOnly_.isEmpty()) {
            possibleLengthLocalOnly_ = other.possibleLengthLocalOnly_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensurePossibleLengthLocalOnlyIsMutable();
            possibleLengthLocalOnly_.addAll(other.possibleLengthLocalOnly_);
          }
          
        }
        if (other.hasExampleNumber()) {
          bitField0_ |= 0x00000010;
          exampleNumber_ = other.exampleNumber_;
          
        }
        setUnknownFields(
            getUnknownFields().concat(other.unknownFields));
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object nationalNumberPattern_ = "";
      /**
       * <code>optional string national_number_pattern = 2;</code>
       *
       * <pre>
       * The national_number_pattern is the pattern that a valid national
       * significant number would match. This specifies information such as its
       * total length and leading digits.
       * </pre>
       */
      public boolean hasNationalNumberPattern() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional string national_number_pattern = 2;</code>
       *
       * <pre>
       * The national_number_pattern is the pattern that a valid national
       * significant number would match. This specifies information such as its
       * total length and leading digits.
       * </pre>
       */
      public java.lang.String getNationalNumberPattern() {
        java.lang.Object ref = nationalNumberPattern_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            nationalNumberPattern_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string national_number_pattern = 2;</code>
       *
       * <pre>
       * The national_number_pattern is the pattern that a valid national
       * significant number would match. This specifies information such as its
       * total length and leading digits.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getNationalNumberPatternBytes() {
        java.lang.Object ref = nationalNumberPattern_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nationalNumberPattern_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string national_number_pattern = 2;</code>
       *
       * <pre>
       * The national_number_pattern is the pattern that a valid national
       * significant number would match. This specifies information such as its
       * total length and leading digits.
       * </pre>
       */
      public Builder setNationalNumberPattern(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        nationalNumberPattern_ = value;
        
        return this;
      }
      /**
       * <code>optional string national_number_pattern = 2;</code>
       *
       * <pre>
       * The national_number_pattern is the pattern that a valid national
       * significant number would match. This specifies information such as its
       * total length and leading digits.
       * </pre>
       */
      public Builder clearNationalNumberPattern() {
        bitField0_ = (bitField0_ & ~0x00000001);
        nationalNumberPattern_ = getDefaultInstance().getNationalNumberPattern();
        
        return this;
      }
      /**
       * <code>optional string national_number_pattern = 2;</code>
       *
       * <pre>
       * The national_number_pattern is the pattern that a valid national
       * significant number would match. This specifies information such as its
       * total length and leading digits.
       * </pre>
       */
      public Builder setNationalNumberPatternBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        nationalNumberPattern_ = value;
        
        return this;
      }

      private java.lang.Object possibleNumberPattern_ = "";
      /**
       * <code>optional string possible_number_pattern = 3;</code>
       *
       * <pre>
       * The possible_number_pattern represents what a potentially valid phone
       * number for this region may be written as. This is a superset of the
       * national_number_pattern above and includes numbers that have the area code
       * omitted. Typically the only restrictions here are in the number of digits.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public boolean hasPossibleNumberPattern() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional string possible_number_pattern = 3;</code>
       *
       * <pre>
       * The possible_number_pattern represents what a potentially valid phone
       * number for this region may be written as. This is a superset of the
       * national_number_pattern above and includes numbers that have the area code
       * omitted. Typically the only restrictions here are in the number of digits.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public java.lang.String getPossibleNumberPattern() {
        java.lang.Object ref = possibleNumberPattern_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            possibleNumberPattern_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string possible_number_pattern = 3;</code>
       *
       * <pre>
       * The possible_number_pattern represents what a potentially valid phone
       * number for this region may be written as. This is a superset of the
       * national_number_pattern above and includes numbers that have the area code
       * omitted. Typically the only restrictions here are in the number of digits.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getPossibleNumberPatternBytes() {
        java.lang.Object ref = possibleNumberPattern_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          possibleNumberPattern_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string possible_number_pattern = 3;</code>
       *
       * <pre>
       * The possible_number_pattern represents what a potentially valid phone
       * number for this region may be written as. This is a superset of the
       * national_number_pattern above and includes numbers that have the area code
       * omitted. Typically the only restrictions here are in the number of digits.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public Builder setPossibleNumberPattern(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        possibleNumberPattern_ = value;
        
        return this;
      }
      /**
       * <code>optional string possible_number_pattern = 3;</code>
       *
       * <pre>
       * The possible_number_pattern represents what a potentially valid phone
       * number for this region may be written as. This is a superset of the
       * national_number_pattern above and includes numbers that have the area code
       * omitted. Typically the only restrictions here are in the number of digits.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public Builder clearPossibleNumberPattern() {
        bitField0_ = (bitField0_ & ~0x00000002);
        possibleNumberPattern_ = getDefaultInstance().getPossibleNumberPattern();
        
        return this;
      }
      /**
       * <code>optional string possible_number_pattern = 3;</code>
       *
       * <pre>
       * The possible_number_pattern represents what a potentially valid phone
       * number for this region may be written as. This is a superset of the
       * national_number_pattern above and includes numbers that have the area code
       * omitted. Typically the only restrictions here are in the number of digits.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public Builder setPossibleNumberPatternBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
        possibleNumberPattern_ = value;
        
        return this;
      }

      private java.util.List<java.lang.Integer> possibleLength_ = java.util.Collections.emptyList();
      private void ensurePossibleLengthIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          possibleLength_ = new java.util.ArrayList<java.lang.Integer>(possibleLength_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <code>repeated int32 possible_length = 9;</code>
       *
       * <pre>
       * These represent the lengths a phone number from this region can be. They
       * will be sorted from smallest to biggest. Note that these lengths are for
       * the full number, without country calling code or national prefix. For
       * example, for the Swiss number +41789270000, in local format 0789270000,
       * this would be 9.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public java.util.List<java.lang.Integer>
          getPossibleLengthList() {
        return java.util.Collections.unmodifiableList(possibleLength_);
      }
      /**
       * <code>repeated int32 possible_length = 9;</code>
       *
       * <pre>
       * These represent the lengths a phone number from this region can be. They
       * will be sorted from smallest to biggest. Note that these lengths are for
       * the full number, without country calling code or national prefix. For
       * example, for the Swiss number +41789270000, in local format 0789270000,
       * this would be 9.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public int getPossibleLengthCount() {
        return possibleLength_.size();
      }
      /**
       * <code>repeated int32 possible_length = 9;</code>
       *
       * <pre>
       * These represent the lengths a phone number from this region can be. They
       * will be sorted from smallest to biggest. Note that these lengths are for
       * the full number, without country calling code or national prefix. For
       * example, for the Swiss number +41789270000, in local format 0789270000,
       * this would be 9.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public int getPossibleLength(int index) {
        return possibleLength_.get(index);
      }
      /**
       * <code>repeated int32 possible_length = 9;</code>
       *
       * <pre>
       * These represent the lengths a phone number from this region can be. They
       * will be sorted from smallest to biggest. Note that these lengths are for
       * the full number, without country calling code or national prefix. For
       * example, for the Swiss number +41789270000, in local format 0789270000,
       * this would be 9.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public Builder setPossibleLength(
          int index, int value) {
        ensurePossibleLengthIsMutable();
        possibleLength_.set(index, value);
        
        return this;
      }
      /**
       * <code>repeated int32 possible_length = 9;</code>
       *
       * <pre>
       * These represent the lengths a phone number from this region can be. They
       * will be sorted from smallest to biggest. Note that these lengths are for
       * the full number, without country calling code or national prefix. For
       * example, for the Swiss number +41789270000, in local format 0789270000,
       * this would be 9.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public Builder addPossibleLength(int value) {
        ensurePossibleLengthIsMutable();
        possibleLength_.add(value);
        
        return this;
      }
      /**
       * <code>repeated int32 possible_length = 9;</code>
       *
       * <pre>
       * These represent the lengths a phone number from this region can be. They
       * will be sorted from smallest to biggest. Note that these lengths are for
       * the full number, without country calling code or national prefix. For
       * example, for the Swiss number +41789270000, in local format 0789270000,
       * this would be 9.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public Builder addAllPossibleLength(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensurePossibleLengthIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, possibleLength_);
        
        return this;
      }
      /**
       * <code>repeated int32 possible_length = 9;</code>
       *
       * <pre>
       * These represent the lengths a phone number from this region can be. They
       * will be sorted from smallest to biggest. Note that these lengths are for
       * the full number, without country calling code or national prefix. For
       * example, for the Swiss number +41789270000, in local format 0789270000,
       * this would be 9.
       * This could be used to highlight tokens in a text that may be a phone
       * number, or to quickly prune numbers that could not possibly be a phone
       * number for this locale.
       * </pre>
       */
      public Builder clearPossibleLength() {
        possibleLength_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        
        return this;
      }

      private java.util.List<java.lang.Integer> possibleLengthLocalOnly_ = java.util.Collections.emptyList();
      private void ensurePossibleLengthLocalOnlyIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          possibleLengthLocalOnly_ = new java.util.ArrayList<java.lang.Integer>(possibleLengthLocalOnly_);
          bitField0_ |= 0x00000008;
         }
      }
      /**
       * <code>repeated int32 possible_length_local_only = 10;</code>
       *
       * <pre>
       * These represent the lengths that only local phone numbers (without an area
       * code) from this region can be. They will be sorted from smallest to
       * biggest. For example, since the American number 456-1234 may be locally
       * diallable, although not diallable from outside the area, 7 could be a
       * possible value.
       * This could be used to highlight tokens in a text that may be a phone
       * number.
       * To our knowledge, area codes are usually only relevant for some fixed-line
       * and mobile numbers, so this field should only be set for those types of
       * numbers (and the general description) - however there are exceptions for
       * NANPA countries.
       * </pre>
       */
      public java.util.List<java.lang.Integer>
          getPossibleLengthLocalOnlyList() {
        return java.util.Collections.unmodifiableList(possibleLengthLocalOnly_);
      }
      /**
       * <code>repeated int32 possible_length_local_only = 10;</code>
       *
       * <pre>
       * These represent the lengths that only local phone numbers (without an area
       * code) from this region can be. They will be sorted from smallest to
       * biggest. For example, since the American number 456-1234 may be locally
       * diallable, although not diallable from outside the area, 7 could be a
       * possible value.
       * This could be used to highlight tokens in a text that may be a phone
       * number.
       * To our knowledge, area codes are usually only relevant for some fixed-line
       * and mobile numbers, so this field should only be set for those types of
       * numbers (and the general description) - however there are exceptions for
       * NANPA countries.
       * </pre>
       */
      public int getPossibleLengthLocalOnlyCount() {
        return possibleLengthLocalOnly_.size();
      }
      /**
       * <code>repeated int32 possible_length_local_only = 10;</code>
       *
       * <pre>
       * These represent the lengths that only local phone numbers (without an area
       * code) from this region can be. They will be sorted from smallest to
       * biggest. For example, since the American number 456-1234 may be locally
       * diallable, although not diallable from outside the area, 7 could be a
       * possible value.
       * This could be used to highlight tokens in a text that may be a phone
       * number.
       * To our knowledge, area codes are usually only relevant for some fixed-line
       * and mobile numbers, so this field should only be set for those types of
       * numbers (and the general description) - however there are exceptions for
       * NANPA countries.
       * </pre>
       */
      public int getPossibleLengthLocalOnly(int index) {
        return possibleLengthLocalOnly_.get(index);
      }
      /**
       * <code>repeated int32 possible_length_local_only = 10;</code>
       *
       * <pre>
       * These represent the lengths that only local phone numbers (without an area
       * code) from this region can be. They will be sorted from smallest to
       * biggest. For example, since the American number 456-1234 may be locally
       * diallable, although not diallable from outside the area, 7 could be a
       * possible value.
       * This could be used to highlight tokens in a text that may be a phone
       * number.
       * To our knowledge, area codes are usually only relevant for some fixed-line
       * and mobile numbers, so this field should only be set for those types of
       * numbers (and the general description) - however there are exceptions for
       * NANPA countries.
       * </pre>
       */
      public Builder setPossibleLengthLocalOnly(
          int index, int value) {
        ensurePossibleLengthLocalOnlyIsMutable();
        possibleLengthLocalOnly_.set(index, value);
        
        return this;
      }
      /**
       * <code>repeated int32 possible_length_local_only = 10;</code>
       *
       * <pre>
       * These represent the lengths that only local phone numbers (without an area
       * code) from this region can be. They will be sorted from smallest to
       * biggest. For example, since the American number 456-1234 may be locally
       * diallable, although not diallable from outside the area, 7 could be a
       * possible value.
       * This could be used to highlight tokens in a text that may be a phone
       * number.
       * To our knowledge, area codes are usually only relevant for some fixed-line
       * and mobile numbers, so this field should only be set for those types of
       * numbers (and the general description) - however there are exceptions for
       * NANPA countries.
       * </pre>
       */
      public Builder addPossibleLengthLocalOnly(int value) {
        ensurePossibleLengthLocalOnlyIsMutable();
        possibleLengthLocalOnly_.add(value);
        
        return this;
      }
      /**
       * <code>repeated int32 possible_length_local_only = 10;</code>
       *
       * <pre>
       * These represent the lengths that only local phone numbers (without an area
       * code) from this region can be. They will be sorted from smallest to
       * biggest. For example, since the American number 456-1234 may be locally
       * diallable, although not diallable from outside the area, 7 could be a
       * possible value.
       * This could be used to highlight tokens in a text that may be a phone
       * number.
       * To our knowledge, area codes are usually only relevant for some fixed-line
       * and mobile numbers, so this field should only be set for those types of
       * numbers (and the general description) - however there are exceptions for
       * NANPA countries.
       * </pre>
       */
      public Builder addAllPossibleLengthLocalOnly(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensurePossibleLengthLocalOnlyIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, possibleLengthLocalOnly_);
        
        return this;
      }
      /**
       * <code>repeated int32 possible_length_local_only = 10;</code>
       *
       * <pre>
       * These represent the lengths that only local phone numbers (without an area
       * code) from this region can be. They will be sorted from smallest to
       * biggest. For example, since the American number 456-1234 may be locally
       * diallable, although not diallable from outside the area, 7 could be a
       * possible value.
       * This could be used to highlight tokens in a text that may be a phone
       * number.
       * To our knowledge, area codes are usually only relevant for some fixed-line
       * and mobile numbers, so this field should only be set for those types of
       * numbers (and the general description) - however there are exceptions for
       * NANPA countries.
       * </pre>
       */
      public Builder clearPossibleLengthLocalOnly() {
        possibleLengthLocalOnly_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        
        return this;
      }

      private java.lang.Object exampleNumber_ = "";
      /**
       * <code>optional string example_number = 6;</code>
       *
       * <pre>
       * An example national significant number for the specific type. It should
       * not contain any formatting information.
       * </pre>
       */
      public boolean hasExampleNumber() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional string example_number = 6;</code>
       *
       * <pre>
       * An example national significant number for the specific type. It should
       * not contain any formatting information.
       * </pre>
       */
      public java.lang.String getExampleNumber() {
        java.lang.Object ref = exampleNumber_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            exampleNumber_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string example_number = 6;</code>
       *
       * <pre>
       * An example national significant number for the specific type. It should
       * not contain any formatting information.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getExampleNumberBytes() {
        java.lang.Object ref = exampleNumber_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          exampleNumber_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string example_number = 6;</code>
       *
       * <pre>
       * An example national significant number for the specific type. It should
       * not contain any formatting information.
       * </pre>
       */
      public Builder setExampleNumber(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        exampleNumber_ = value;
        
        return this;
      }
      /**
       * <code>optional string example_number = 6;</code>
       *
       * <pre>
       * An example national significant number for the specific type. It should
       * not contain any formatting information.
       * </pre>
       */
      public Builder clearExampleNumber() {
        bitField0_ = (bitField0_ & ~0x00000010);
        exampleNumber_ = getDefaultInstance().getExampleNumber();
        
        return this;
      }
      /**
       * <code>optional string example_number = 6;</code>
       *
       * <pre>
       * An example national significant number for the specific type. It should
       * not contain any formatting information.
       * </pre>
       */
      public Builder setExampleNumberBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000010;
        exampleNumber_ = value;
        
        return this;
      }

      // @@protoc_insertion_point(builder_scope:i18n.phonenumbers.PhoneNumberDesc)
    }

    static {
      defaultInstance = new PhoneNumberDesc(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:i18n.phonenumbers.PhoneNumberDesc)
  }

  public interface PhoneMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:i18n.phonenumbers.PhoneMetadata)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
     *
     * <pre>
     * The general_desc contains information which is a superset of descriptions
     * for all types of phone numbers. If any element is missing in the
     * description of a specific type in the XML file, the element will inherit
     * from its counterpart in the general_desc. Every locale is assumed to have
     * fixed line and mobile numbers - if these types are missing in the
     * PhoneNumberMetadata XML file, they will inherit all fields from the
     * general_desc. For all other types that are generally relevant to normal
     * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
     * file, it will be given a national_number_pattern of "NA" and a
     * possible_number_pattern of "NA".
     * </pre>
     */
    boolean hasGeneralDesc();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
     *
     * <pre>
     * The general_desc contains information which is a superset of descriptions
     * for all types of phone numbers. If any element is missing in the
     * description of a specific type in the XML file, the element will inherit
     * from its counterpart in the general_desc. Every locale is assumed to have
     * fixed line and mobile numbers - if these types are missing in the
     * PhoneNumberMetadata XML file, they will inherit all fields from the
     * general_desc. For all other types that are generally relevant to normal
     * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
     * file, it will be given a national_number_pattern of "NA" and a
     * possible_number_pattern of "NA".
     * </pre>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getGeneralDesc();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
     */
    boolean hasFixedLine();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getFixedLine();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
     */
    boolean hasMobile();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getMobile();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
     */
    boolean hasTollFree();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getTollFree();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
     */
    boolean hasPremiumRate();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPremiumRate();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
     */
    boolean hasSharedCost();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getSharedCost();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
     */
    boolean hasPersonalNumber();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPersonalNumber();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
     */
    boolean hasVoip();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getVoip();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
     */
    boolean hasPager();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPager();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
     */
    boolean hasUan();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getUan();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
     */
    boolean hasEmergency();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getEmergency();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
     */
    boolean hasVoicemail();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getVoicemail();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
     */
    boolean hasShortCode();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getShortCode();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
     */
    boolean hasStandardRate();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getStandardRate();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
     */
    boolean hasCarrierSpecific();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getCarrierSpecific();

    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
     *
     * <pre>
     * The rules here distinguish the numbers that are only able to be dialled
     * nationally.
     * </pre>
     */
    boolean hasNoInternationalDialling();
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
     *
     * <pre>
     * The rules here distinguish the numbers that are only able to be dialled
     * nationally.
     * </pre>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getNoInternationalDialling();

    /**
     * <code>required string id = 9;</code>
     *
     * <pre>
     * The ISO 3166-1 alpha-2 representation of a country/region, with the
     * exception of "country calling codes" used for non-geographical entities,
     * such as Universal International Toll Free Number (+800). These are all
     * given the ID "001", since this is the numeric region code for the world
     * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
     * </pre>
     */
    boolean hasId();
    /**
     * <code>required string id = 9;</code>
     *
     * <pre>
     * The ISO 3166-1 alpha-2 representation of a country/region, with the
     * exception of "country calling codes" used for non-geographical entities,
     * such as Universal International Toll Free Number (+800). These are all
     * given the ID "001", since this is the numeric region code for the world
     * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
     * </pre>
     */
    java.lang.String getId();
    /**
     * <code>required string id = 9;</code>
     *
     * <pre>
     * The ISO 3166-1 alpha-2 representation of a country/region, with the
     * exception of "country calling codes" used for non-geographical entities,
     * such as Universal International Toll Free Number (+800). These are all
     * given the ID "001", since this is the numeric region code for the world
     * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
     * </pre>
     */
    com.google.protobuf.ByteString
        getIdBytes();

    /**
     * <code>optional int32 country_code = 10;</code>
     *
     * <pre>
     * The country calling code that one would dial from overseas when trying to
     * dial a phone number in this country. For example, this would be "64" for
     * New Zealand.
     * </pre>
     */
    boolean hasCountryCode();
    /**
     * <code>optional int32 country_code = 10;</code>
     *
     * <pre>
     * The country calling code that one would dial from overseas when trying to
     * dial a phone number in this country. For example, this would be "64" for
     * New Zealand.
     * </pre>
     */
    int getCountryCode();

    /**
     * <code>optional string international_prefix = 11;</code>
     *
     * <pre>
     * The international_prefix of country A is the number that needs to be
     * dialled from country A to another country (country B). This is followed
     * by the country code for country B. Note that some countries may have more
     * than one international prefix, and for those cases, a regular expression
     * matching the international prefixes will be stored in this field.
     * </pre>
     */
    boolean hasInternationalPrefix();
    /**
     * <code>optional string international_prefix = 11;</code>
     *
     * <pre>
     * The international_prefix of country A is the number that needs to be
     * dialled from country A to another country (country B). This is followed
     * by the country code for country B. Note that some countries may have more
     * than one international prefix, and for those cases, a regular expression
     * matching the international prefixes will be stored in this field.
     * </pre>
     */
    java.lang.String getInternationalPrefix();
    /**
     * <code>optional string international_prefix = 11;</code>
     *
     * <pre>
     * The international_prefix of country A is the number that needs to be
     * dialled from country A to another country (country B). This is followed
     * by the country code for country B. Note that some countries may have more
     * than one international prefix, and for those cases, a regular expression
     * matching the international prefixes will be stored in this field.
     * </pre>
     */
    com.google.protobuf.ByteString
        getInternationalPrefixBytes();

    /**
     * <code>optional string preferred_international_prefix = 17;</code>
     *
     * <pre>
     * If more than one international prefix is present, a preferred prefix can
     * be specified here for out-of-country formatting purposes. If this field is
     * not present, and multiple international prefixes are present, then "+"
     * will be used instead.
     * </pre>
     */
    boolean hasPreferredInternationalPrefix();
    /**
     * <code>optional string preferred_international_prefix = 17;</code>
     *
     * <pre>
     * If more than one international prefix is present, a preferred prefix can
     * be specified here for out-of-country formatting purposes. If this field is
     * not present, and multiple international prefixes are present, then "+"
     * will be used instead.
     * </pre>
     */
    java.lang.String getPreferredInternationalPrefix();
    /**
     * <code>optional string preferred_international_prefix = 17;</code>
     *
     * <pre>
     * If more than one international prefix is present, a preferred prefix can
     * be specified here for out-of-country formatting purposes. If this field is
     * not present, and multiple international prefixes are present, then "+"
     * will be used instead.
     * </pre>
     */
    com.google.protobuf.ByteString
        getPreferredInternationalPrefixBytes();

    /**
     * <code>optional string national_prefix = 12;</code>
     *
     * <pre>
     * The national prefix of country A is the number that needs to be dialled
     * before the national significant number when dialling internally. This
     * would not be dialled when dialling internationally. For example, in New
     * Zealand, the number that would be locally dialled as 09 345 3456 would be
     * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
     * prefix.
     * </pre>
     */
    boolean hasNationalPrefix();
    /**
     * <code>optional string national_prefix = 12;</code>
     *
     * <pre>
     * The national prefix of country A is the number that needs to be dialled
     * before the national significant number when dialling internally. This
     * would not be dialled when dialling internationally. For example, in New
     * Zealand, the number that would be locally dialled as 09 345 3456 would be
     * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
     * prefix.
     * </pre>
     */
    java.lang.String getNationalPrefix();
    /**
     * <code>optional string national_prefix = 12;</code>
     *
     * <pre>
     * The national prefix of country A is the number that needs to be dialled
     * before the national significant number when dialling internally. This
     * would not be dialled when dialling internationally. For example, in New
     * Zealand, the number that would be locally dialled as 09 345 3456 would be
     * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
     * prefix.
     * </pre>
     */
    com.google.protobuf.ByteString
        getNationalPrefixBytes();

    /**
     * <code>optional string preferred_extn_prefix = 13;</code>
     *
     * <pre>
     * The preferred prefix when specifying an extension in this country. This is
     * used for formatting only, and if this is not specified, a suitable default
     * should be used instead. For example, if you wanted extensions to be
     * formatted in the following way:
     * 1 (365) 345 445 ext. 2345
     * " ext. "  should be the preferred extension prefix.
     * </pre>
     */
    boolean hasPreferredExtnPrefix();
    /**
     * <code>optional string preferred_extn_prefix = 13;</code>
     *
     * <pre>
     * The preferred prefix when specifying an extension in this country. This is
     * used for formatting only, and if this is not specified, a suitable default
     * should be used instead. For example, if you wanted extensions to be
     * formatted in the following way:
     * 1 (365) 345 445 ext. 2345
     * " ext. "  should be the preferred extension prefix.
     * </pre>
     */
    java.lang.String getPreferredExtnPrefix();
    /**
     * <code>optional string preferred_extn_prefix = 13;</code>
     *
     * <pre>
     * The preferred prefix when specifying an extension in this country. This is
     * used for formatting only, and if this is not specified, a suitable default
     * should be used instead. For example, if you wanted extensions to be
     * formatted in the following way:
     * 1 (365) 345 445 ext. 2345
     * " ext. "  should be the preferred extension prefix.
     * </pre>
     */
    com.google.protobuf.ByteString
        getPreferredExtnPrefixBytes();

    /**
     * <code>optional string national_prefix_for_parsing = 15;</code>
     *
     * <pre>
     * This field is used for cases where the national prefix of a country
     * contains a carrier selection code, and is written in the form of a
     * regular expression. For example, to dial the number 2222-2222 in
     * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
     * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
     * only other possible carrier selection code is 32, the field will
     * contain "03[12]".
     * When it is missing from the XML file, this field inherits the value of
     * national_prefix, if that is present.
     * </pre>
     */
    boolean hasNationalPrefixForParsing();
    /**
     * <code>optional string national_prefix_for_parsing = 15;</code>
     *
     * <pre>
     * This field is used for cases where the national prefix of a country
     * contains a carrier selection code, and is written in the form of a
     * regular expression. For example, to dial the number 2222-2222 in
     * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
     * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
     * only other possible carrier selection code is 32, the field will
     * contain "03[12]".
     * When it is missing from the XML file, this field inherits the value of
     * national_prefix, if that is present.
     * </pre>
     */
    java.lang.String getNationalPrefixForParsing();
    /**
     * <code>optional string national_prefix_for_parsing = 15;</code>
     *
     * <pre>
     * This field is used for cases where the national prefix of a country
     * contains a carrier selection code, and is written in the form of a
     * regular expression. For example, to dial the number 2222-2222 in
     * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
     * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
     * only other possible carrier selection code is 32, the field will
     * contain "03[12]".
     * When it is missing from the XML file, this field inherits the value of
     * national_prefix, if that is present.
     * </pre>
     */
    com.google.protobuf.ByteString
        getNationalPrefixForParsingBytes();

    /**
     * <code>optional string national_prefix_transform_rule = 16;</code>
     *
     * <pre>
     * This field is only populated and used under very rare situations.
     * For example, mobile numbers in Argentina are written in two completely
     * different ways when dialed in-country and out-of-country
     * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
     * This field is used together with national_prefix_for_parsing to transform
     * the number into a particular representation for storing in the phonenumber
     * proto buffer in those rare cases.
     * </pre>
     */
    boolean hasNationalPrefixTransformRule();
    /**
     * <code>optional string national_prefix_transform_rule = 16;</code>
     *
     * <pre>
     * This field is only populated and used under very rare situations.
     * For example, mobile numbers in Argentina are written in two completely
     * different ways when dialed in-country and out-of-country
     * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
     * This field is used together with national_prefix_for_parsing to transform
     * the number into a particular representation for storing in the phonenumber
     * proto buffer in those rare cases.
     * </pre>
     */
    java.lang.String getNationalPrefixTransformRule();
    /**
     * <code>optional string national_prefix_transform_rule = 16;</code>
     *
     * <pre>
     * This field is only populated and used under very rare situations.
     * For example, mobile numbers in Argentina are written in two completely
     * different ways when dialed in-country and out-of-country
     * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
     * This field is used together with national_prefix_for_parsing to transform
     * the number into a particular representation for storing in the phonenumber
     * proto buffer in those rare cases.
     * </pre>
     */
    com.google.protobuf.ByteString
        getNationalPrefixTransformRuleBytes();

    /**
     * <code>optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];</code>
     *
     * <pre>
     * Specifies whether the mobile and fixed-line patterns are the same or not.
     * This is used to speed up determining phone number type in countries where
     * these two types of phone numbers can never be distinguished.
     * </pre>
     */
    boolean hasSameMobileAndFixedLinePattern();
    /**
     * <code>optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];</code>
     *
     * <pre>
     * Specifies whether the mobile and fixed-line patterns are the same or not.
     * This is used to speed up determining phone number type in countries where
     * these two types of phone numbers can never be distinguished.
     * </pre>
     */
    boolean getSameMobileAndFixedLinePattern();

    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
     *
     * <pre>
     * Note that the number format here is used for formatting only, not parsing.
     * Hence all the varied ways a user *may* write a number need not be recorded
     * - just the ideal way we would like to format it for them. When this element
     * is absent, the national significant number will be formatted as a whole
     * without any formatting applied.
     * </pre>
     */
    java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> 
        getNumberFormatList();
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
     *
     * <pre>
     * Note that the number format here is used for formatting only, not parsing.
     * Hence all the varied ways a user *may* write a number need not be recorded
     * - just the ideal way we would like to format it for them. When this element
     * is absent, the national significant number will be formatted as a whole
     * without any formatting applied.
     * </pre>
     */
    com.google.i18n.phonenumbers.Phonemetadata.NumberFormat getNumberFormat(int index);
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
     *
     * <pre>
     * Note that the number format here is used for formatting only, not parsing.
     * Hence all the varied ways a user *may* write a number need not be recorded
     * - just the ideal way we would like to format it for them. When this element
     * is absent, the national significant number will be formatted as a whole
     * without any formatting applied.
     * </pre>
     */
    int getNumberFormatCount();

    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
     *
     * <pre>
     * This field is populated only when the national significant number is
     * formatted differently when it forms part of the INTERNATIONAL format
     * and NATIONAL format. A case in point is mobile numbers in Argentina:
     * The number, which would be written in INTERNATIONAL format as
     * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
     * format. In this case, the prefix 9 is inserted when dialling from
     * overseas, but otherwise the prefix 0 and the carrier selection code
     * 15 (inserted after the area code of 343) is used.
     * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
     * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
     * defaults to the same value as the &lt;format&gt; tag.
     * Examples:
     *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
     *   "NA":
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     * </pre>
     */
    java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> 
        getIntlNumberFormatList();
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
     *
     * <pre>
     * This field is populated only when the national significant number is
     * formatted differently when it forms part of the INTERNATIONAL format
     * and NATIONAL format. A case in point is mobile numbers in Argentina:
     * The number, which would be written in INTERNATIONAL format as
     * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
     * format. In this case, the prefix 9 is inserted when dialling from
     * overseas, but otherwise the prefix 0 and the carrier selection code
     * 15 (inserted after the area code of 343) is used.
     * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
     * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
     * defaults to the same value as the &lt;format&gt; tag.
     * Examples:
     *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
     *   "NA":
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     * </pre>
     */
    com.google.i18n.phonenumbers.Phonemetadata.NumberFormat getIntlNumberFormat(int index);
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
     *
     * <pre>
     * This field is populated only when the national significant number is
     * formatted differently when it forms part of the INTERNATIONAL format
     * and NATIONAL format. A case in point is mobile numbers in Argentina:
     * The number, which would be written in INTERNATIONAL format as
     * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
     * format. In this case, the prefix 9 is inserted when dialling from
     * overseas, but otherwise the prefix 0 and the carrier selection code
     * 15 (inserted after the area code of 343) is used.
     * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
     * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
     * defaults to the same value as the &lt;format&gt; tag.
     * Examples:
     *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
     *   "NA":
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     * </pre>
     */
    int getIntlNumberFormatCount();

    /**
     * <code>optional bool main_country_for_code = 22 [default = false];</code>
     *
     * <pre>
     * This field is set when this country is considered to be the main country
     * for a calling code. It may not be set by more than one country with the
     * same calling code, and it should not be set by countries with a unique
     * calling code. This can be used to indicate that "GB" is the main country
     * for the calling code "44" for example, rather than Jersey or the Isle of
     * Man.
     * </pre>
     */
    boolean hasMainCountryForCode();
    /**
     * <code>optional bool main_country_for_code = 22 [default = false];</code>
     *
     * <pre>
     * This field is set when this country is considered to be the main country
     * for a calling code. It may not be set by more than one country with the
     * same calling code, and it should not be set by countries with a unique
     * calling code. This can be used to indicate that "GB" is the main country
     * for the calling code "44" for example, rather than Jersey or the Isle of
     * Man.
     * </pre>
     */
    boolean getMainCountryForCode();

    /**
     * <code>optional string leading_digits = 23;</code>
     *
     * <pre>
     * This field is populated only for countries or regions that share a country
     * calling code. If a number matches this pattern, it could belong to this
     * region. This is not intended as a replacement for IsValidForRegion, and
     * does not mean the number must come from this region (for example, 800
     * numbers are valid for all NANPA countries.) This field should be a regular
     * expression of the expected prefix match.
     * </pre>
     */
    boolean hasLeadingDigits();
    /**
     * <code>optional string leading_digits = 23;</code>
     *
     * <pre>
     * This field is populated only for countries or regions that share a country
     * calling code. If a number matches this pattern, it could belong to this
     * region. This is not intended as a replacement for IsValidForRegion, and
     * does not mean the number must come from this region (for example, 800
     * numbers are valid for all NANPA countries.) This field should be a regular
     * expression of the expected prefix match.
     * </pre>
     */
    java.lang.String getLeadingDigits();
    /**
     * <code>optional string leading_digits = 23;</code>
     *
     * <pre>
     * This field is populated only for countries or regions that share a country
     * calling code. If a number matches this pattern, it could belong to this
     * region. This is not intended as a replacement for IsValidForRegion, and
     * does not mean the number must come from this region (for example, 800
     * numbers are valid for all NANPA countries.) This field should be a regular
     * expression of the expected prefix match.
     * </pre>
     */
    com.google.protobuf.ByteString
        getLeadingDigitsBytes();

    /**
     * <code>optional bool leading_zero_possible = 26 [default = false];</code>
     *
     * <pre>
     * The leading zero in a phone number is meaningful in some countries (e.g.
     * Italy). This means they cannot be dropped from the national number when
     * converting into international format. If leading zeros are possible for
     * valid international numbers for this region/country then set this to true.
     * This only needs to be set for the region that is the main_country_for_code
     * and all regions associated with that calling code will use the same
     * setting.
     * </pre>
     */
    boolean hasLeadingZeroPossible();
    /**
     * <code>optional bool leading_zero_possible = 26 [default = false];</code>
     *
     * <pre>
     * The leading zero in a phone number is meaningful in some countries (e.g.
     * Italy). This means they cannot be dropped from the national number when
     * converting into international format. If leading zeros are possible for
     * valid international numbers for this region/country then set this to true.
     * This only needs to be set for the region that is the main_country_for_code
     * and all regions associated with that calling code will use the same
     * setting.
     * </pre>
     */
    boolean getLeadingZeroPossible();

    /**
     * <code>optional bool mobile_number_portable_region = 32 [default = false];</code>
     *
     * <pre>
     * This field is set when this country has implemented mobile number
     * portability. This means that transferring mobile numbers between carriers
     * is allowed. A consequence of this is that phone prefix to carrier mapping
     * is less reliable.
     * </pre>
     */
    boolean hasMobileNumberPortableRegion();
    /**
     * <code>optional bool mobile_number_portable_region = 32 [default = false];</code>
     *
     * <pre>
     * This field is set when this country has implemented mobile number
     * portability. This means that transferring mobile numbers between carriers
     * is allowed. A consequence of this is that phone prefix to carrier mapping
     * is less reliable.
     * </pre>
     */
    boolean getMobileNumberPortableRegion();
  }
  /**
   * Protobuf type {@code i18n.phonenumbers.PhoneMetadata}
   *
   * <pre>
   * If you add, remove, or rename fields, or change their semantics, check if you
   * should change the excludable field sets or the behavior in MetadataFilter.
   * </pre>
   */
  public static final class PhoneMetadata extends
      com.google.protobuf.GeneratedMessageLite implements
      // @@protoc_insertion_point(message_implements:i18n.phonenumbers.PhoneMetadata)
      PhoneMetadataOrBuilder {
    // Use PhoneMetadata.newBuilder() to construct.
    private PhoneMetadata(com.google.protobuf.GeneratedMessageLite.Builder builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private PhoneMetadata(boolean noInit) { this.unknownFields = com.google.protobuf.ByteString.EMPTY;}

    private static final PhoneMetadata defaultInstance;
    public static PhoneMetadata getDefaultInstance() {
      return defaultInstance;
    }

    public PhoneMetadata getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.ByteString unknownFields;
    private PhoneMetadata(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.ByteString.Output unknownFieldsOutput =
          com.google.protobuf.ByteString.newOutput();
      com.google.protobuf.CodedOutputStream unknownFieldsCodedOutput =
          com.google.protobuf.CodedOutputStream.newInstance(
              unknownFieldsOutput);
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFieldsCodedOutput,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = generalDesc_.toBuilder();
              }
              generalDesc_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(generalDesc_);
                generalDesc_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = fixedLine_.toBuilder();
              }
              fixedLine_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(fixedLine_);
                fixedLine_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = mobile_.toBuilder();
              }
              mobile_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(mobile_);
                mobile_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 34: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000008) == 0x00000008)) {
                subBuilder = tollFree_.toBuilder();
              }
              tollFree_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(tollFree_);
                tollFree_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000008;
              break;
            }
            case 42: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000010) == 0x00000010)) {
                subBuilder = premiumRate_.toBuilder();
              }
              premiumRate_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(premiumRate_);
                premiumRate_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000010;
              break;
            }
            case 50: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000020) == 0x00000020)) {
                subBuilder = sharedCost_.toBuilder();
              }
              sharedCost_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(sharedCost_);
                sharedCost_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000020;
              break;
            }
            case 58: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000040) == 0x00000040)) {
                subBuilder = personalNumber_.toBuilder();
              }
              personalNumber_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(personalNumber_);
                personalNumber_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000040;
              break;
            }
            case 66: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000080) == 0x00000080)) {
                subBuilder = voip_.toBuilder();
              }
              voip_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(voip_);
                voip_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000080;
              break;
            }
            case 74: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00010000;
              id_ = bs;
              break;
            }
            case 80: {
              bitField0_ |= 0x00020000;
              countryCode_ = input.readInt32();
              break;
            }
            case 90: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00040000;
              internationalPrefix_ = bs;
              break;
            }
            case 98: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00100000;
              nationalPrefix_ = bs;
              break;
            }
            case 106: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00200000;
              preferredExtnPrefix_ = bs;
              break;
            }
            case 122: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00400000;
              nationalPrefixForParsing_ = bs;
              break;
            }
            case 130: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00800000;
              nationalPrefixTransformRule_ = bs;
              break;
            }
            case 138: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00080000;
              preferredInternationalPrefix_ = bs;
              break;
            }
            case 144: {
              bitField0_ |= 0x01000000;
              sameMobileAndFixedLinePattern_ = input.readBool();
              break;
            }
            case 154: {
              if (!((mutable_bitField0_ & 0x02000000) == 0x02000000)) {
                numberFormat_ = new java.util.ArrayList<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat>();
                mutable_bitField0_ |= 0x02000000;
              }
              numberFormat_.add(input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.PARSER, extensionRegistry));
              break;
            }
            case 162: {
              if (!((mutable_bitField0_ & 0x04000000) == 0x04000000)) {
                intlNumberFormat_ = new java.util.ArrayList<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat>();
                mutable_bitField0_ |= 0x04000000;
              }
              intlNumberFormat_.add(input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.PARSER, extensionRegistry));
              break;
            }
            case 170: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000100) == 0x00000100)) {
                subBuilder = pager_.toBuilder();
              }
              pager_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(pager_);
                pager_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000100;
              break;
            }
            case 176: {
              bitField0_ |= 0x02000000;
              mainCountryForCode_ = input.readBool();
              break;
            }
            case 186: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x04000000;
              leadingDigits_ = bs;
              break;
            }
            case 194: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00008000) == 0x00008000)) {
                subBuilder = noInternationalDialling_.toBuilder();
              }
              noInternationalDialling_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(noInternationalDialling_);
                noInternationalDialling_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00008000;
              break;
            }
            case 202: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000200) == 0x00000200)) {
                subBuilder = uan_.toBuilder();
              }
              uan_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(uan_);
                uan_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000200;
              break;
            }
            case 208: {
              bitField0_ |= 0x08000000;
              leadingZeroPossible_ = input.readBool();
              break;
            }
            case 218: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000400) == 0x00000400)) {
                subBuilder = emergency_.toBuilder();
              }
              emergency_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(emergency_);
                emergency_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000400;
              break;
            }
            case 226: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00000800) == 0x00000800)) {
                subBuilder = voicemail_.toBuilder();
              }
              voicemail_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(voicemail_);
                voicemail_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000800;
              break;
            }
            case 234: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00001000) == 0x00001000)) {
                subBuilder = shortCode_.toBuilder();
              }
              shortCode_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(shortCode_);
                shortCode_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00001000;
              break;
            }
            case 242: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00002000) == 0x00002000)) {
                subBuilder = standardRate_.toBuilder();
              }
              standardRate_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(standardRate_);
                standardRate_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00002000;
              break;
            }
            case 250: {
              com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder subBuilder = null;
              if (((bitField0_ & 0x00004000) == 0x00004000)) {
                subBuilder = carrierSpecific_.toBuilder();
              }
              carrierSpecific_ = input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(carrierSpecific_);
                carrierSpecific_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00004000;
              break;
            }
            case 256: {
              bitField0_ |= 0x10000000;
              mobileNumberPortableRegion_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x02000000) == 0x02000000)) {
          numberFormat_ = java.util.Collections.unmodifiableList(numberFormat_);
        }
        if (((mutable_bitField0_ & 0x04000000) == 0x04000000)) {
          intlNumberFormat_ = java.util.Collections.unmodifiableList(intlNumberFormat_);
        }
        try {
          unknownFieldsCodedOutput.flush();
        } catch (java.io.IOException e) {
        // Should not happen
        } finally {
          unknownFields = unknownFieldsOutput.toByteString();
        }
        makeExtensionsImmutable();
      }
    }
    public static com.google.protobuf.Parser<PhoneMetadata> PARSER =
        new com.google.protobuf.AbstractParser<PhoneMetadata>() {
      public PhoneMetadata parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PhoneMetadata(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<PhoneMetadata> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    public static final int GENERAL_DESC_FIELD_NUMBER = 1;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc generalDesc_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
     *
     * <pre>
     * The general_desc contains information which is a superset of descriptions
     * for all types of phone numbers. If any element is missing in the
     * description of a specific type in the XML file, the element will inherit
     * from its counterpart in the general_desc. Every locale is assumed to have
     * fixed line and mobile numbers - if these types are missing in the
     * PhoneNumberMetadata XML file, they will inherit all fields from the
     * general_desc. For all other types that are generally relevant to normal
     * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
     * file, it will be given a national_number_pattern of "NA" and a
     * possible_number_pattern of "NA".
     * </pre>
     */
    public boolean hasGeneralDesc() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
     *
     * <pre>
     * The general_desc contains information which is a superset of descriptions
     * for all types of phone numbers. If any element is missing in the
     * description of a specific type in the XML file, the element will inherit
     * from its counterpart in the general_desc. Every locale is assumed to have
     * fixed line and mobile numbers - if these types are missing in the
     * PhoneNumberMetadata XML file, they will inherit all fields from the
     * general_desc. For all other types that are generally relevant to normal
     * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
     * file, it will be given a national_number_pattern of "NA" and a
     * possible_number_pattern of "NA".
     * </pre>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getGeneralDesc() {
      return generalDesc_;
    }

    public static final int FIXED_LINE_FIELD_NUMBER = 2;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc fixedLine_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
     */
    public boolean hasFixedLine() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getFixedLine() {
      return fixedLine_;
    }

    public static final int MOBILE_FIELD_NUMBER = 3;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc mobile_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
     */
    public boolean hasMobile() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getMobile() {
      return mobile_;
    }

    public static final int TOLL_FREE_FIELD_NUMBER = 4;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc tollFree_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
     */
    public boolean hasTollFree() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getTollFree() {
      return tollFree_;
    }

    public static final int PREMIUM_RATE_FIELD_NUMBER = 5;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc premiumRate_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
     */
    public boolean hasPremiumRate() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPremiumRate() {
      return premiumRate_;
    }

    public static final int SHARED_COST_FIELD_NUMBER = 6;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc sharedCost_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
     */
    public boolean hasSharedCost() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getSharedCost() {
      return sharedCost_;
    }

    public static final int PERSONAL_NUMBER_FIELD_NUMBER = 7;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc personalNumber_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
     */
    public boolean hasPersonalNumber() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPersonalNumber() {
      return personalNumber_;
    }

    public static final int VOIP_FIELD_NUMBER = 8;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc voip_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
     */
    public boolean hasVoip() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getVoip() {
      return voip_;
    }

    public static final int PAGER_FIELD_NUMBER = 21;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc pager_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
     */
    public boolean hasPager() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPager() {
      return pager_;
    }

    public static final int UAN_FIELD_NUMBER = 25;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc uan_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
     */
    public boolean hasUan() {
      return ((bitField0_ & 0x00000200) == 0x00000200);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getUan() {
      return uan_;
    }

    public static final int EMERGENCY_FIELD_NUMBER = 27;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc emergency_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
     */
    public boolean hasEmergency() {
      return ((bitField0_ & 0x00000400) == 0x00000400);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getEmergency() {
      return emergency_;
    }

    public static final int VOICEMAIL_FIELD_NUMBER = 28;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc voicemail_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
     */
    public boolean hasVoicemail() {
      return ((bitField0_ & 0x00000800) == 0x00000800);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getVoicemail() {
      return voicemail_;
    }

    public static final int SHORT_CODE_FIELD_NUMBER = 29;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc shortCode_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
     */
    public boolean hasShortCode() {
      return ((bitField0_ & 0x00001000) == 0x00001000);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getShortCode() {
      return shortCode_;
    }

    public static final int STANDARD_RATE_FIELD_NUMBER = 30;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc standardRate_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
     */
    public boolean hasStandardRate() {
      return ((bitField0_ & 0x00002000) == 0x00002000);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getStandardRate() {
      return standardRate_;
    }

    public static final int CARRIER_SPECIFIC_FIELD_NUMBER = 31;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc carrierSpecific_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
     */
    public boolean hasCarrierSpecific() {
      return ((bitField0_ & 0x00004000) == 0x00004000);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getCarrierSpecific() {
      return carrierSpecific_;
    }

    public static final int NO_INTERNATIONAL_DIALLING_FIELD_NUMBER = 24;
    private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc noInternationalDialling_;
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
     *
     * <pre>
     * The rules here distinguish the numbers that are only able to be dialled
     * nationally.
     * </pre>
     */
    public boolean hasNoInternationalDialling() {
      return ((bitField0_ & 0x00008000) == 0x00008000);
    }
    /**
     * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
     *
     * <pre>
     * The rules here distinguish the numbers that are only able to be dialled
     * nationally.
     * </pre>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getNoInternationalDialling() {
      return noInternationalDialling_;
    }

    public static final int ID_FIELD_NUMBER = 9;
    private java.lang.Object id_;
    /**
     * <code>required string id = 9;</code>
     *
     * <pre>
     * The ISO 3166-1 alpha-2 representation of a country/region, with the
     * exception of "country calling codes" used for non-geographical entities,
     * such as Universal International Toll Free Number (+800). These are all
     * given the ID "001", since this is the numeric region code for the world
     * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
     * </pre>
     */
    public boolean hasId() {
      return ((bitField0_ & 0x00010000) == 0x00010000);
    }
    /**
     * <code>required string id = 9;</code>
     *
     * <pre>
     * The ISO 3166-1 alpha-2 representation of a country/region, with the
     * exception of "country calling codes" used for non-geographical entities,
     * such as Universal International Toll Free Number (+800). These are all
     * given the ID "001", since this is the numeric region code for the world
     * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
     * </pre>
     */
    public java.lang.String getId() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          id_ = s;
        }
        return s;
      }
    }
    /**
     * <code>required string id = 9;</code>
     *
     * <pre>
     * The ISO 3166-1 alpha-2 representation of a country/region, with the
     * exception of "country calling codes" used for non-geographical entities,
     * such as Universal International Toll Free Number (+800). These are all
     * given the ID "001", since this is the numeric region code for the world
     * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
     * </pre>
     */
    public com.google.protobuf.ByteString
        getIdBytes() {
      java.lang.Object ref = id_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        id_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COUNTRY_CODE_FIELD_NUMBER = 10;
    private int countryCode_;
    /**
     * <code>optional int32 country_code = 10;</code>
     *
     * <pre>
     * The country calling code that one would dial from overseas when trying to
     * dial a phone number in this country. For example, this would be "64" for
     * New Zealand.
     * </pre>
     */
    public boolean hasCountryCode() {
      return ((bitField0_ & 0x00020000) == 0x00020000);
    }
    /**
     * <code>optional int32 country_code = 10;</code>
     *
     * <pre>
     * The country calling code that one would dial from overseas when trying to
     * dial a phone number in this country. For example, this would be "64" for
     * New Zealand.
     * </pre>
     */
    public int getCountryCode() {
      return countryCode_;
    }

    public static final int INTERNATIONAL_PREFIX_FIELD_NUMBER = 11;
    private java.lang.Object internationalPrefix_;
    /**
     * <code>optional string international_prefix = 11;</code>
     *
     * <pre>
     * The international_prefix of country A is the number that needs to be
     * dialled from country A to another country (country B). This is followed
     * by the country code for country B. Note that some countries may have more
     * than one international prefix, and for those cases, a regular expression
     * matching the international prefixes will be stored in this field.
     * </pre>
     */
    public boolean hasInternationalPrefix() {
      return ((bitField0_ & 0x00040000) == 0x00040000);
    }
    /**
     * <code>optional string international_prefix = 11;</code>
     *
     * <pre>
     * The international_prefix of country A is the number that needs to be
     * dialled from country A to another country (country B). This is followed
     * by the country code for country B. Note that some countries may have more
     * than one international prefix, and for those cases, a regular expression
     * matching the international prefixes will be stored in this field.
     * </pre>
     */
    public java.lang.String getInternationalPrefix() {
      java.lang.Object ref = internationalPrefix_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          internationalPrefix_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string international_prefix = 11;</code>
     *
     * <pre>
     * The international_prefix of country A is the number that needs to be
     * dialled from country A to another country (country B). This is followed
     * by the country code for country B. Note that some countries may have more
     * than one international prefix, and for those cases, a regular expression
     * matching the international prefixes will be stored in this field.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getInternationalPrefixBytes() {
      java.lang.Object ref = internationalPrefix_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        internationalPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PREFERRED_INTERNATIONAL_PREFIX_FIELD_NUMBER = 17;
    private java.lang.Object preferredInternationalPrefix_;
    /**
     * <code>optional string preferred_international_prefix = 17;</code>
     *
     * <pre>
     * If more than one international prefix is present, a preferred prefix can
     * be specified here for out-of-country formatting purposes. If this field is
     * not present, and multiple international prefixes are present, then "+"
     * will be used instead.
     * </pre>
     */
    public boolean hasPreferredInternationalPrefix() {
      return ((bitField0_ & 0x00080000) == 0x00080000);
    }
    /**
     * <code>optional string preferred_international_prefix = 17;</code>
     *
     * <pre>
     * If more than one international prefix is present, a preferred prefix can
     * be specified here for out-of-country formatting purposes. If this field is
     * not present, and multiple international prefixes are present, then "+"
     * will be used instead.
     * </pre>
     */
    public java.lang.String getPreferredInternationalPrefix() {
      java.lang.Object ref = preferredInternationalPrefix_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          preferredInternationalPrefix_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string preferred_international_prefix = 17;</code>
     *
     * <pre>
     * If more than one international prefix is present, a preferred prefix can
     * be specified here for out-of-country formatting purposes. If this field is
     * not present, and multiple international prefixes are present, then "+"
     * will be used instead.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getPreferredInternationalPrefixBytes() {
      java.lang.Object ref = preferredInternationalPrefix_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        preferredInternationalPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NATIONAL_PREFIX_FIELD_NUMBER = 12;
    private java.lang.Object nationalPrefix_;
    /**
     * <code>optional string national_prefix = 12;</code>
     *
     * <pre>
     * The national prefix of country A is the number that needs to be dialled
     * before the national significant number when dialling internally. This
     * would not be dialled when dialling internationally. For example, in New
     * Zealand, the number that would be locally dialled as 09 345 3456 would be
     * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
     * prefix.
     * </pre>
     */
    public boolean hasNationalPrefix() {
      return ((bitField0_ & 0x00100000) == 0x00100000);
    }
    /**
     * <code>optional string national_prefix = 12;</code>
     *
     * <pre>
     * The national prefix of country A is the number that needs to be dialled
     * before the national significant number when dialling internally. This
     * would not be dialled when dialling internationally. For example, in New
     * Zealand, the number that would be locally dialled as 09 345 3456 would be
     * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
     * prefix.
     * </pre>
     */
    public java.lang.String getNationalPrefix() {
      java.lang.Object ref = nationalPrefix_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          nationalPrefix_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string national_prefix = 12;</code>
     *
     * <pre>
     * The national prefix of country A is the number that needs to be dialled
     * before the national significant number when dialling internally. This
     * would not be dialled when dialling internationally. For example, in New
     * Zealand, the number that would be locally dialled as 09 345 3456 would be
     * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
     * prefix.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getNationalPrefixBytes() {
      java.lang.Object ref = nationalPrefix_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nationalPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PREFERRED_EXTN_PREFIX_FIELD_NUMBER = 13;
    private java.lang.Object preferredExtnPrefix_;
    /**
     * <code>optional string preferred_extn_prefix = 13;</code>
     *
     * <pre>
     * The preferred prefix when specifying an extension in this country. This is
     * used for formatting only, and if this is not specified, a suitable default
     * should be used instead. For example, if you wanted extensions to be
     * formatted in the following way:
     * 1 (365) 345 445 ext. 2345
     * " ext. "  should be the preferred extension prefix.
     * </pre>
     */
    public boolean hasPreferredExtnPrefix() {
      return ((bitField0_ & 0x00200000) == 0x00200000);
    }
    /**
     * <code>optional string preferred_extn_prefix = 13;</code>
     *
     * <pre>
     * The preferred prefix when specifying an extension in this country. This is
     * used for formatting only, and if this is not specified, a suitable default
     * should be used instead. For example, if you wanted extensions to be
     * formatted in the following way:
     * 1 (365) 345 445 ext. 2345
     * " ext. "  should be the preferred extension prefix.
     * </pre>
     */
    public java.lang.String getPreferredExtnPrefix() {
      java.lang.Object ref = preferredExtnPrefix_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          preferredExtnPrefix_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string preferred_extn_prefix = 13;</code>
     *
     * <pre>
     * The preferred prefix when specifying an extension in this country. This is
     * used for formatting only, and if this is not specified, a suitable default
     * should be used instead. For example, if you wanted extensions to be
     * formatted in the following way:
     * 1 (365) 345 445 ext. 2345
     * " ext. "  should be the preferred extension prefix.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getPreferredExtnPrefixBytes() {
      java.lang.Object ref = preferredExtnPrefix_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        preferredExtnPrefix_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NATIONAL_PREFIX_FOR_PARSING_FIELD_NUMBER = 15;
    private java.lang.Object nationalPrefixForParsing_;
    /**
     * <code>optional string national_prefix_for_parsing = 15;</code>
     *
     * <pre>
     * This field is used for cases where the national prefix of a country
     * contains a carrier selection code, and is written in the form of a
     * regular expression. For example, to dial the number 2222-2222 in
     * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
     * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
     * only other possible carrier selection code is 32, the field will
     * contain "03[12]".
     * When it is missing from the XML file, this field inherits the value of
     * national_prefix, if that is present.
     * </pre>
     */
    public boolean hasNationalPrefixForParsing() {
      return ((bitField0_ & 0x00400000) == 0x00400000);
    }
    /**
     * <code>optional string national_prefix_for_parsing = 15;</code>
     *
     * <pre>
     * This field is used for cases where the national prefix of a country
     * contains a carrier selection code, and is written in the form of a
     * regular expression. For example, to dial the number 2222-2222 in
     * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
     * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
     * only other possible carrier selection code is 32, the field will
     * contain "03[12]".
     * When it is missing from the XML file, this field inherits the value of
     * national_prefix, if that is present.
     * </pre>
     */
    public java.lang.String getNationalPrefixForParsing() {
      java.lang.Object ref = nationalPrefixForParsing_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          nationalPrefixForParsing_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string national_prefix_for_parsing = 15;</code>
     *
     * <pre>
     * This field is used for cases where the national prefix of a country
     * contains a carrier selection code, and is written in the form of a
     * regular expression. For example, to dial the number 2222-2222 in
     * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
     * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
     * only other possible carrier selection code is 32, the field will
     * contain "03[12]".
     * When it is missing from the XML file, this field inherits the value of
     * national_prefix, if that is present.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getNationalPrefixForParsingBytes() {
      java.lang.Object ref = nationalPrefixForParsing_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nationalPrefixForParsing_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NATIONAL_PREFIX_TRANSFORM_RULE_FIELD_NUMBER = 16;
    private java.lang.Object nationalPrefixTransformRule_;
    /**
     * <code>optional string national_prefix_transform_rule = 16;</code>
     *
     * <pre>
     * This field is only populated and used under very rare situations.
     * For example, mobile numbers in Argentina are written in two completely
     * different ways when dialed in-country and out-of-country
     * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
     * This field is used together with national_prefix_for_parsing to transform
     * the number into a particular representation for storing in the phonenumber
     * proto buffer in those rare cases.
     * </pre>
     */
    public boolean hasNationalPrefixTransformRule() {
      return ((bitField0_ & 0x00800000) == 0x00800000);
    }
    /**
     * <code>optional string national_prefix_transform_rule = 16;</code>
     *
     * <pre>
     * This field is only populated and used under very rare situations.
     * For example, mobile numbers in Argentina are written in two completely
     * different ways when dialed in-country and out-of-country
     * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
     * This field is used together with national_prefix_for_parsing to transform
     * the number into a particular representation for storing in the phonenumber
     * proto buffer in those rare cases.
     * </pre>
     */
    public java.lang.String getNationalPrefixTransformRule() {
      java.lang.Object ref = nationalPrefixTransformRule_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          nationalPrefixTransformRule_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string national_prefix_transform_rule = 16;</code>
     *
     * <pre>
     * This field is only populated and used under very rare situations.
     * For example, mobile numbers in Argentina are written in two completely
     * different ways when dialed in-country and out-of-country
     * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
     * This field is used together with national_prefix_for_parsing to transform
     * the number into a particular representation for storing in the phonenumber
     * proto buffer in those rare cases.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getNationalPrefixTransformRuleBytes() {
      java.lang.Object ref = nationalPrefixTransformRule_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        nationalPrefixTransformRule_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SAME_MOBILE_AND_FIXED_LINE_PATTERN_FIELD_NUMBER = 18;
    private boolean sameMobileAndFixedLinePattern_;
    /**
     * <code>optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];</code>
     *
     * <pre>
     * Specifies whether the mobile and fixed-line patterns are the same or not.
     * This is used to speed up determining phone number type in countries where
     * these two types of phone numbers can never be distinguished.
     * </pre>
     */
    public boolean hasSameMobileAndFixedLinePattern() {
      return ((bitField0_ & 0x01000000) == 0x01000000);
    }
    /**
     * <code>optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];</code>
     *
     * <pre>
     * Specifies whether the mobile and fixed-line patterns are the same or not.
     * This is used to speed up determining phone number type in countries where
     * these two types of phone numbers can never be distinguished.
     * </pre>
     */
    public boolean getSameMobileAndFixedLinePattern() {
      return sameMobileAndFixedLinePattern_;
    }

    public static final int NUMBER_FORMAT_FIELD_NUMBER = 19;
    private java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> numberFormat_;
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
     *
     * <pre>
     * Note that the number format here is used for formatting only, not parsing.
     * Hence all the varied ways a user *may* write a number need not be recorded
     * - just the ideal way we would like to format it for them. When this element
     * is absent, the national significant number will be formatted as a whole
     * without any formatting applied.
     * </pre>
     */
    public java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> getNumberFormatList() {
      return numberFormat_;
    }
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
     *
     * <pre>
     * Note that the number format here is used for formatting only, not parsing.
     * Hence all the varied ways a user *may* write a number need not be recorded
     * - just the ideal way we would like to format it for them. When this element
     * is absent, the national significant number will be formatted as a whole
     * without any formatting applied.
     * </pre>
     */
    public java.util.List<? extends com.google.i18n.phonenumbers.Phonemetadata.NumberFormatOrBuilder> 
        getNumberFormatOrBuilderList() {
      return numberFormat_;
    }
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
     *
     * <pre>
     * Note that the number format here is used for formatting only, not parsing.
     * Hence all the varied ways a user *may* write a number need not be recorded
     * - just the ideal way we would like to format it for them. When this element
     * is absent, the national significant number will be formatted as a whole
     * without any formatting applied.
     * </pre>
     */
    public int getNumberFormatCount() {
      return numberFormat_.size();
    }
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
     *
     * <pre>
     * Note that the number format here is used for formatting only, not parsing.
     * Hence all the varied ways a user *may* write a number need not be recorded
     * - just the ideal way we would like to format it for them. When this element
     * is absent, the national significant number will be formatted as a whole
     * without any formatting applied.
     * </pre>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.NumberFormat getNumberFormat(int index) {
      return numberFormat_.get(index);
    }
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
     *
     * <pre>
     * Note that the number format here is used for formatting only, not parsing.
     * Hence all the varied ways a user *may* write a number need not be recorded
     * - just the ideal way we would like to format it for them. When this element
     * is absent, the national significant number will be formatted as a whole
     * without any formatting applied.
     * </pre>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.NumberFormatOrBuilder getNumberFormatOrBuilder(
        int index) {
      return numberFormat_.get(index);
    }

    public static final int INTL_NUMBER_FORMAT_FIELD_NUMBER = 20;
    private java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> intlNumberFormat_;
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
     *
     * <pre>
     * This field is populated only when the national significant number is
     * formatted differently when it forms part of the INTERNATIONAL format
     * and NATIONAL format. A case in point is mobile numbers in Argentina:
     * The number, which would be written in INTERNATIONAL format as
     * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
     * format. In this case, the prefix 9 is inserted when dialling from
     * overseas, but otherwise the prefix 0 and the carrier selection code
     * 15 (inserted after the area code of 343) is used.
     * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
     * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
     * defaults to the same value as the &lt;format&gt; tag.
     * Examples:
     *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
     *   "NA":
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     * </pre>
     */
    public java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> getIntlNumberFormatList() {
      return intlNumberFormat_;
    }
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
     *
     * <pre>
     * This field is populated only when the national significant number is
     * formatted differently when it forms part of the INTERNATIONAL format
     * and NATIONAL format. A case in point is mobile numbers in Argentina:
     * The number, which would be written in INTERNATIONAL format as
     * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
     * format. In this case, the prefix 9 is inserted when dialling from
     * overseas, but otherwise the prefix 0 and the carrier selection code
     * 15 (inserted after the area code of 343) is used.
     * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
     * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
     * defaults to the same value as the &lt;format&gt; tag.
     * Examples:
     *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
     *   "NA":
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     * </pre>
     */
    public java.util.List<? extends com.google.i18n.phonenumbers.Phonemetadata.NumberFormatOrBuilder> 
        getIntlNumberFormatOrBuilderList() {
      return intlNumberFormat_;
    }
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
     *
     * <pre>
     * This field is populated only when the national significant number is
     * formatted differently when it forms part of the INTERNATIONAL format
     * and NATIONAL format. A case in point is mobile numbers in Argentina:
     * The number, which would be written in INTERNATIONAL format as
     * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
     * format. In this case, the prefix 9 is inserted when dialling from
     * overseas, but otherwise the prefix 0 and the carrier selection code
     * 15 (inserted after the area code of 343) is used.
     * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
     * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
     * defaults to the same value as the &lt;format&gt; tag.
     * Examples:
     *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
     *   "NA":
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     * </pre>
     */
    public int getIntlNumberFormatCount() {
      return intlNumberFormat_.size();
    }
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
     *
     * <pre>
     * This field is populated only when the national significant number is
     * formatted differently when it forms part of the INTERNATIONAL format
     * and NATIONAL format. A case in point is mobile numbers in Argentina:
     * The number, which would be written in INTERNATIONAL format as
     * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
     * format. In this case, the prefix 9 is inserted when dialling from
     * overseas, but otherwise the prefix 0 and the carrier selection code
     * 15 (inserted after the area code of 343) is used.
     * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
     * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
     * defaults to the same value as the &lt;format&gt; tag.
     * Examples:
     *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
     *   "NA":
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     * </pre>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.NumberFormat getIntlNumberFormat(int index) {
      return intlNumberFormat_.get(index);
    }
    /**
     * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
     *
     * <pre>
     * This field is populated only when the national significant number is
     * formatted differently when it forms part of the INTERNATIONAL format
     * and NATIONAL format. A case in point is mobile numbers in Argentina:
     * The number, which would be written in INTERNATIONAL format as
     * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
     * format. In this case, the prefix 9 is inserted when dialling from
     * overseas, but otherwise the prefix 0 and the carrier selection code
     * 15 (inserted after the area code of 343) is used.
     * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
     * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
     * defaults to the same value as the &lt;format&gt; tag.
     * Examples:
     *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
     *   "NA":
     *     &lt;numberFormat pattern=....&gt;
     *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
     *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
     *     &lt;/numberFormat&gt;
     * </pre>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.NumberFormatOrBuilder getIntlNumberFormatOrBuilder(
        int index) {
      return intlNumberFormat_.get(index);
    }

    public static final int MAIN_COUNTRY_FOR_CODE_FIELD_NUMBER = 22;
    private boolean mainCountryForCode_;
    /**
     * <code>optional bool main_country_for_code = 22 [default = false];</code>
     *
     * <pre>
     * This field is set when this country is considered to be the main country
     * for a calling code. It may not be set by more than one country with the
     * same calling code, and it should not be set by countries with a unique
     * calling code. This can be used to indicate that "GB" is the main country
     * for the calling code "44" for example, rather than Jersey or the Isle of
     * Man.
     * </pre>
     */
    public boolean hasMainCountryForCode() {
      return ((bitField0_ & 0x02000000) == 0x02000000);
    }
    /**
     * <code>optional bool main_country_for_code = 22 [default = false];</code>
     *
     * <pre>
     * This field is set when this country is considered to be the main country
     * for a calling code. It may not be set by more than one country with the
     * same calling code, and it should not be set by countries with a unique
     * calling code. This can be used to indicate that "GB" is the main country
     * for the calling code "44" for example, rather than Jersey or the Isle of
     * Man.
     * </pre>
     */
    public boolean getMainCountryForCode() {
      return mainCountryForCode_;
    }

    public static final int LEADING_DIGITS_FIELD_NUMBER = 23;
    private java.lang.Object leadingDigits_;
    /**
     * <code>optional string leading_digits = 23;</code>
     *
     * <pre>
     * This field is populated only for countries or regions that share a country
     * calling code. If a number matches this pattern, it could belong to this
     * region. This is not intended as a replacement for IsValidForRegion, and
     * does not mean the number must come from this region (for example, 800
     * numbers are valid for all NANPA countries.) This field should be a regular
     * expression of the expected prefix match.
     * </pre>
     */
    public boolean hasLeadingDigits() {
      return ((bitField0_ & 0x04000000) == 0x04000000);
    }
    /**
     * <code>optional string leading_digits = 23;</code>
     *
     * <pre>
     * This field is populated only for countries or regions that share a country
     * calling code. If a number matches this pattern, it could belong to this
     * region. This is not intended as a replacement for IsValidForRegion, and
     * does not mean the number must come from this region (for example, 800
     * numbers are valid for all NANPA countries.) This field should be a regular
     * expression of the expected prefix match.
     * </pre>
     */
    public java.lang.String getLeadingDigits() {
      java.lang.Object ref = leadingDigits_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          leadingDigits_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string leading_digits = 23;</code>
     *
     * <pre>
     * This field is populated only for countries or regions that share a country
     * calling code. If a number matches this pattern, it could belong to this
     * region. This is not intended as a replacement for IsValidForRegion, and
     * does not mean the number must come from this region (for example, 800
     * numbers are valid for all NANPA countries.) This field should be a regular
     * expression of the expected prefix match.
     * </pre>
     */
    public com.google.protobuf.ByteString
        getLeadingDigitsBytes() {
      java.lang.Object ref = leadingDigits_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        leadingDigits_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int LEADING_ZERO_POSSIBLE_FIELD_NUMBER = 26;
    private boolean leadingZeroPossible_;
    /**
     * <code>optional bool leading_zero_possible = 26 [default = false];</code>
     *
     * <pre>
     * The leading zero in a phone number is meaningful in some countries (e.g.
     * Italy). This means they cannot be dropped from the national number when
     * converting into international format. If leading zeros are possible for
     * valid international numbers for this region/country then set this to true.
     * This only needs to be set for the region that is the main_country_for_code
     * and all regions associated with that calling code will use the same
     * setting.
     * </pre>
     */
    public boolean hasLeadingZeroPossible() {
      return ((bitField0_ & 0x08000000) == 0x08000000);
    }
    /**
     * <code>optional bool leading_zero_possible = 26 [default = false];</code>
     *
     * <pre>
     * The leading zero in a phone number is meaningful in some countries (e.g.
     * Italy). This means they cannot be dropped from the national number when
     * converting into international format. If leading zeros are possible for
     * valid international numbers for this region/country then set this to true.
     * This only needs to be set for the region that is the main_country_for_code
     * and all regions associated with that calling code will use the same
     * setting.
     * </pre>
     */
    public boolean getLeadingZeroPossible() {
      return leadingZeroPossible_;
    }

    public static final int MOBILE_NUMBER_PORTABLE_REGION_FIELD_NUMBER = 32;
    private boolean mobileNumberPortableRegion_;
    /**
     * <code>optional bool mobile_number_portable_region = 32 [default = false];</code>
     *
     * <pre>
     * This field is set when this country has implemented mobile number
     * portability. This means that transferring mobile numbers between carriers
     * is allowed. A consequence of this is that phone prefix to carrier mapping
     * is less reliable.
     * </pre>
     */
    public boolean hasMobileNumberPortableRegion() {
      return ((bitField0_ & 0x10000000) == 0x10000000);
    }
    /**
     * <code>optional bool mobile_number_portable_region = 32 [default = false];</code>
     *
     * <pre>
     * This field is set when this country has implemented mobile number
     * portability. This means that transferring mobile numbers between carriers
     * is allowed. A consequence of this is that phone prefix to carrier mapping
     * is less reliable.
     * </pre>
     */
    public boolean getMobileNumberPortableRegion() {
      return mobileNumberPortableRegion_;
    }

    private void initFields() {
      generalDesc_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      fixedLine_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      mobile_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      tollFree_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      premiumRate_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      sharedCost_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      personalNumber_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      voip_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      pager_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      uan_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      emergency_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      voicemail_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      shortCode_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      standardRate_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      carrierSpecific_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      noInternationalDialling_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      id_ = "";
      countryCode_ = 0;
      internationalPrefix_ = "";
      preferredInternationalPrefix_ = "";
      nationalPrefix_ = "";
      preferredExtnPrefix_ = "";
      nationalPrefixForParsing_ = "";
      nationalPrefixTransformRule_ = "";
      sameMobileAndFixedLinePattern_ = false;
      numberFormat_ = java.util.Collections.emptyList();
      intlNumberFormat_ = java.util.Collections.emptyList();
      mainCountryForCode_ = false;
      leadingDigits_ = "";
      leadingZeroPossible_ = false;
      mobileNumberPortableRegion_ = false;
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasId()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getNumberFormatCount(); i++) {
        if (!getNumberFormat(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      for (int i = 0; i < getIntlNumberFormatCount(); i++) {
        if (!getIntlNumberFormat(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, generalDesc_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, fixedLine_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, mobile_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeMessage(4, tollFree_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeMessage(5, premiumRate_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeMessage(6, sharedCost_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeMessage(7, personalNumber_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeMessage(8, voip_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        output.writeBytes(9, getIdBytes());
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        output.writeInt32(10, countryCode_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        output.writeBytes(11, getInternationalPrefixBytes());
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        output.writeBytes(12, getNationalPrefixBytes());
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        output.writeBytes(13, getPreferredExtnPrefixBytes());
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        output.writeBytes(15, getNationalPrefixForParsingBytes());
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        output.writeBytes(16, getNationalPrefixTransformRuleBytes());
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        output.writeBytes(17, getPreferredInternationalPrefixBytes());
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        output.writeBool(18, sameMobileAndFixedLinePattern_);
      }
      for (int i = 0; i < numberFormat_.size(); i++) {
        output.writeMessage(19, numberFormat_.get(i));
      }
      for (int i = 0; i < intlNumberFormat_.size(); i++) {
        output.writeMessage(20, intlNumberFormat_.get(i));
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeMessage(21, pager_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        output.writeBool(22, mainCountryForCode_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        output.writeBytes(23, getLeadingDigitsBytes());
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        output.writeMessage(24, noInternationalDialling_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        output.writeMessage(25, uan_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        output.writeBool(26, leadingZeroPossible_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        output.writeMessage(27, emergency_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        output.writeMessage(28, voicemail_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        output.writeMessage(29, shortCode_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        output.writeMessage(30, standardRate_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        output.writeMessage(31, carrierSpecific_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        output.writeBool(32, mobileNumberPortableRegion_);
      }
      output.writeRawBytes(unknownFields);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, generalDesc_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, fixedLine_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, mobile_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, tollFree_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, premiumRate_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, sharedCost_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, personalNumber_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, voip_);
      }
      if (((bitField0_ & 0x00010000) == 0x00010000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(9, getIdBytes());
      }
      if (((bitField0_ & 0x00020000) == 0x00020000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(10, countryCode_);
      }
      if (((bitField0_ & 0x00040000) == 0x00040000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(11, getInternationalPrefixBytes());
      }
      if (((bitField0_ & 0x00100000) == 0x00100000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(12, getNationalPrefixBytes());
      }
      if (((bitField0_ & 0x00200000) == 0x00200000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(13, getPreferredExtnPrefixBytes());
      }
      if (((bitField0_ & 0x00400000) == 0x00400000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(15, getNationalPrefixForParsingBytes());
      }
      if (((bitField0_ & 0x00800000) == 0x00800000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(16, getNationalPrefixTransformRuleBytes());
      }
      if (((bitField0_ & 0x00080000) == 0x00080000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(17, getPreferredInternationalPrefixBytes());
      }
      if (((bitField0_ & 0x01000000) == 0x01000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(18, sameMobileAndFixedLinePattern_);
      }
      for (int i = 0; i < numberFormat_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(19, numberFormat_.get(i));
      }
      for (int i = 0; i < intlNumberFormat_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(20, intlNumberFormat_.get(i));
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(21, pager_);
      }
      if (((bitField0_ & 0x02000000) == 0x02000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(22, mainCountryForCode_);
      }
      if (((bitField0_ & 0x04000000) == 0x04000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(23, getLeadingDigitsBytes());
      }
      if (((bitField0_ & 0x00008000) == 0x00008000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(24, noInternationalDialling_);
      }
      if (((bitField0_ & 0x00000200) == 0x00000200)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(25, uan_);
      }
      if (((bitField0_ & 0x08000000) == 0x08000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(26, leadingZeroPossible_);
      }
      if (((bitField0_ & 0x00000400) == 0x00000400)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(27, emergency_);
      }
      if (((bitField0_ & 0x00000800) == 0x00000800)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(28, voicemail_);
      }
      if (((bitField0_ & 0x00001000) == 0x00001000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(29, shortCode_);
      }
      if (((bitField0_ & 0x00002000) == 0x00002000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(30, standardRate_);
      }
      if (((bitField0_ & 0x00004000) == 0x00004000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(31, carrierSpecific_);
      }
      if (((bitField0_ & 0x10000000) == 0x10000000)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(32, mobileNumberPortableRegion_);
      }
      size += unknownFields.size();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    /**
     * Protobuf type {@code i18n.phonenumbers.PhoneMetadata}
     *
     * <pre>
     * If you add, remove, or rename fields, or change their semantics, check if you
     * should change the excludable field sets or the behavior in MetadataFilter.
     * </pre>
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata, Builder>
        implements
        // @@protoc_insertion_point(builder_implements:i18n.phonenumbers.PhoneMetadata)
        com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataOrBuilder {
      // Construct using com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        generalDesc_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000001);
        fixedLine_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000002);
        mobile_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000004);
        tollFree_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000008);
        premiumRate_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000010);
        sharedCost_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000020);
        personalNumber_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000040);
        voip_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000080);
        pager_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000100);
        uan_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000200);
        emergency_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000400);
        voicemail_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00000800);
        shortCode_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00001000);
        standardRate_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00002000);
        carrierSpecific_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00004000);
        noInternationalDialling_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
        bitField0_ = (bitField0_ & ~0x00008000);
        id_ = "";
        bitField0_ = (bitField0_ & ~0x00010000);
        countryCode_ = 0;
        bitField0_ = (bitField0_ & ~0x00020000);
        internationalPrefix_ = "";
        bitField0_ = (bitField0_ & ~0x00040000);
        preferredInternationalPrefix_ = "";
        bitField0_ = (bitField0_ & ~0x00080000);
        nationalPrefix_ = "";
        bitField0_ = (bitField0_ & ~0x00100000);
        preferredExtnPrefix_ = "";
        bitField0_ = (bitField0_ & ~0x00200000);
        nationalPrefixForParsing_ = "";
        bitField0_ = (bitField0_ & ~0x00400000);
        nationalPrefixTransformRule_ = "";
        bitField0_ = (bitField0_ & ~0x00800000);
        sameMobileAndFixedLinePattern_ = false;
        bitField0_ = (bitField0_ & ~0x01000000);
        numberFormat_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x02000000);
        intlNumberFormat_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x04000000);
        mainCountryForCode_ = false;
        bitField0_ = (bitField0_ & ~0x08000000);
        leadingDigits_ = "";
        bitField0_ = (bitField0_ & ~0x10000000);
        leadingZeroPossible_ = false;
        bitField0_ = (bitField0_ & ~0x20000000);
        mobileNumberPortableRegion_ = false;
        bitField0_ = (bitField0_ & ~0x40000000);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata getDefaultInstanceForType() {
        return com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata.getDefaultInstance();
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata build() {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata buildPartial() {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata result = new com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.generalDesc_ = generalDesc_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.fixedLine_ = fixedLine_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.mobile_ = mobile_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.tollFree_ = tollFree_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.premiumRate_ = premiumRate_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.sharedCost_ = sharedCost_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.personalNumber_ = personalNumber_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.voip_ = voip_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.pager_ = pager_;
        if (((from_bitField0_ & 0x00000200) == 0x00000200)) {
          to_bitField0_ |= 0x00000200;
        }
        result.uan_ = uan_;
        if (((from_bitField0_ & 0x00000400) == 0x00000400)) {
          to_bitField0_ |= 0x00000400;
        }
        result.emergency_ = emergency_;
        if (((from_bitField0_ & 0x00000800) == 0x00000800)) {
          to_bitField0_ |= 0x00000800;
        }
        result.voicemail_ = voicemail_;
        if (((from_bitField0_ & 0x00001000) == 0x00001000)) {
          to_bitField0_ |= 0x00001000;
        }
        result.shortCode_ = shortCode_;
        if (((from_bitField0_ & 0x00002000) == 0x00002000)) {
          to_bitField0_ |= 0x00002000;
        }
        result.standardRate_ = standardRate_;
        if (((from_bitField0_ & 0x00004000) == 0x00004000)) {
          to_bitField0_ |= 0x00004000;
        }
        result.carrierSpecific_ = carrierSpecific_;
        if (((from_bitField0_ & 0x00008000) == 0x00008000)) {
          to_bitField0_ |= 0x00008000;
        }
        result.noInternationalDialling_ = noInternationalDialling_;
        if (((from_bitField0_ & 0x00010000) == 0x00010000)) {
          to_bitField0_ |= 0x00010000;
        }
        result.id_ = id_;
        if (((from_bitField0_ & 0x00020000) == 0x00020000)) {
          to_bitField0_ |= 0x00020000;
        }
        result.countryCode_ = countryCode_;
        if (((from_bitField0_ & 0x00040000) == 0x00040000)) {
          to_bitField0_ |= 0x00040000;
        }
        result.internationalPrefix_ = internationalPrefix_;
        if (((from_bitField0_ & 0x00080000) == 0x00080000)) {
          to_bitField0_ |= 0x00080000;
        }
        result.preferredInternationalPrefix_ = preferredInternationalPrefix_;
        if (((from_bitField0_ & 0x00100000) == 0x00100000)) {
          to_bitField0_ |= 0x00100000;
        }
        result.nationalPrefix_ = nationalPrefix_;
        if (((from_bitField0_ & 0x00200000) == 0x00200000)) {
          to_bitField0_ |= 0x00200000;
        }
        result.preferredExtnPrefix_ = preferredExtnPrefix_;
        if (((from_bitField0_ & 0x00400000) == 0x00400000)) {
          to_bitField0_ |= 0x00400000;
        }
        result.nationalPrefixForParsing_ = nationalPrefixForParsing_;
        if (((from_bitField0_ & 0x00800000) == 0x00800000)) {
          to_bitField0_ |= 0x00800000;
        }
        result.nationalPrefixTransformRule_ = nationalPrefixTransformRule_;
        if (((from_bitField0_ & 0x01000000) == 0x01000000)) {
          to_bitField0_ |= 0x01000000;
        }
        result.sameMobileAndFixedLinePattern_ = sameMobileAndFixedLinePattern_;
        if (((bitField0_ & 0x02000000) == 0x02000000)) {
          numberFormat_ = java.util.Collections.unmodifiableList(numberFormat_);
          bitField0_ = (bitField0_ & ~0x02000000);
        }
        result.numberFormat_ = numberFormat_;
        if (((bitField0_ & 0x04000000) == 0x04000000)) {
          intlNumberFormat_ = java.util.Collections.unmodifiableList(intlNumberFormat_);
          bitField0_ = (bitField0_ & ~0x04000000);
        }
        result.intlNumberFormat_ = intlNumberFormat_;
        if (((from_bitField0_ & 0x08000000) == 0x08000000)) {
          to_bitField0_ |= 0x02000000;
        }
        result.mainCountryForCode_ = mainCountryForCode_;
        if (((from_bitField0_ & 0x10000000) == 0x10000000)) {
          to_bitField0_ |= 0x04000000;
        }
        result.leadingDigits_ = leadingDigits_;
        if (((from_bitField0_ & 0x20000000) == 0x20000000)) {
          to_bitField0_ |= 0x08000000;
        }
        result.leadingZeroPossible_ = leadingZeroPossible_;
        if (((from_bitField0_ & 0x40000000) == 0x40000000)) {
          to_bitField0_ |= 0x10000000;
        }
        result.mobileNumberPortableRegion_ = mobileNumberPortableRegion_;
        result.bitField0_ = to_bitField0_;
        return result;
      }

      public Builder mergeFrom(com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata other) {
        if (other == com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata.getDefaultInstance()) return this;
        if (other.hasGeneralDesc()) {
          mergeGeneralDesc(other.getGeneralDesc());
        }
        if (other.hasFixedLine()) {
          mergeFixedLine(other.getFixedLine());
        }
        if (other.hasMobile()) {
          mergeMobile(other.getMobile());
        }
        if (other.hasTollFree()) {
          mergeTollFree(other.getTollFree());
        }
        if (other.hasPremiumRate()) {
          mergePremiumRate(other.getPremiumRate());
        }
        if (other.hasSharedCost()) {
          mergeSharedCost(other.getSharedCost());
        }
        if (other.hasPersonalNumber()) {
          mergePersonalNumber(other.getPersonalNumber());
        }
        if (other.hasVoip()) {
          mergeVoip(other.getVoip());
        }
        if (other.hasPager()) {
          mergePager(other.getPager());
        }
        if (other.hasUan()) {
          mergeUan(other.getUan());
        }
        if (other.hasEmergency()) {
          mergeEmergency(other.getEmergency());
        }
        if (other.hasVoicemail()) {
          mergeVoicemail(other.getVoicemail());
        }
        if (other.hasShortCode()) {
          mergeShortCode(other.getShortCode());
        }
        if (other.hasStandardRate()) {
          mergeStandardRate(other.getStandardRate());
        }
        if (other.hasCarrierSpecific()) {
          mergeCarrierSpecific(other.getCarrierSpecific());
        }
        if (other.hasNoInternationalDialling()) {
          mergeNoInternationalDialling(other.getNoInternationalDialling());
        }
        if (other.hasId()) {
          bitField0_ |= 0x00010000;
          id_ = other.id_;
          
        }
        if (other.hasCountryCode()) {
          setCountryCode(other.getCountryCode());
        }
        if (other.hasInternationalPrefix()) {
          bitField0_ |= 0x00040000;
          internationalPrefix_ = other.internationalPrefix_;
          
        }
        if (other.hasPreferredInternationalPrefix()) {
          bitField0_ |= 0x00080000;
          preferredInternationalPrefix_ = other.preferredInternationalPrefix_;
          
        }
        if (other.hasNationalPrefix()) {
          bitField0_ |= 0x00100000;
          nationalPrefix_ = other.nationalPrefix_;
          
        }
        if (other.hasPreferredExtnPrefix()) {
          bitField0_ |= 0x00200000;
          preferredExtnPrefix_ = other.preferredExtnPrefix_;
          
        }
        if (other.hasNationalPrefixForParsing()) {
          bitField0_ |= 0x00400000;
          nationalPrefixForParsing_ = other.nationalPrefixForParsing_;
          
        }
        if (other.hasNationalPrefixTransformRule()) {
          bitField0_ |= 0x00800000;
          nationalPrefixTransformRule_ = other.nationalPrefixTransformRule_;
          
        }
        if (other.hasSameMobileAndFixedLinePattern()) {
          setSameMobileAndFixedLinePattern(other.getSameMobileAndFixedLinePattern());
        }
        if (!other.numberFormat_.isEmpty()) {
          if (numberFormat_.isEmpty()) {
            numberFormat_ = other.numberFormat_;
            bitField0_ = (bitField0_ & ~0x02000000);
          } else {
            ensureNumberFormatIsMutable();
            numberFormat_.addAll(other.numberFormat_);
          }
          
        }
        if (!other.intlNumberFormat_.isEmpty()) {
          if (intlNumberFormat_.isEmpty()) {
            intlNumberFormat_ = other.intlNumberFormat_;
            bitField0_ = (bitField0_ & ~0x04000000);
          } else {
            ensureIntlNumberFormatIsMutable();
            intlNumberFormat_.addAll(other.intlNumberFormat_);
          }
          
        }
        if (other.hasMainCountryForCode()) {
          setMainCountryForCode(other.getMainCountryForCode());
        }
        if (other.hasLeadingDigits()) {
          bitField0_ |= 0x10000000;
          leadingDigits_ = other.leadingDigits_;
          
        }
        if (other.hasLeadingZeroPossible()) {
          setLeadingZeroPossible(other.getLeadingZeroPossible());
        }
        if (other.hasMobileNumberPortableRegion()) {
          setMobileNumberPortableRegion(other.getMobileNumberPortableRegion());
        }
        setUnknownFields(
            getUnknownFields().concat(other.unknownFields));
        return this;
      }

      public final boolean isInitialized() {
        if (!hasId()) {
          
          return false;
        }
        for (int i = 0; i < getNumberFormatCount(); i++) {
          if (!getNumberFormat(i).isInitialized()) {
            
            return false;
          }
        }
        for (int i = 0; i < getIntlNumberFormatCount(); i++) {
          if (!getIntlNumberFormat(i).isInitialized()) {
            
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc generalDesc_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
       *
       * <pre>
       * The general_desc contains information which is a superset of descriptions
       * for all types of phone numbers. If any element is missing in the
       * description of a specific type in the XML file, the element will inherit
       * from its counterpart in the general_desc. Every locale is assumed to have
       * fixed line and mobile numbers - if these types are missing in the
       * PhoneNumberMetadata XML file, they will inherit all fields from the
       * general_desc. For all other types that are generally relevant to normal
       * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
       * file, it will be given a national_number_pattern of "NA" and a
       * possible_number_pattern of "NA".
       * </pre>
       */
      public boolean hasGeneralDesc() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
       *
       * <pre>
       * The general_desc contains information which is a superset of descriptions
       * for all types of phone numbers. If any element is missing in the
       * description of a specific type in the XML file, the element will inherit
       * from its counterpart in the general_desc. Every locale is assumed to have
       * fixed line and mobile numbers - if these types are missing in the
       * PhoneNumberMetadata XML file, they will inherit all fields from the
       * general_desc. For all other types that are generally relevant to normal
       * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
       * file, it will be given a national_number_pattern of "NA" and a
       * possible_number_pattern of "NA".
       * </pre>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getGeneralDesc() {
        return generalDesc_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
       *
       * <pre>
       * The general_desc contains information which is a superset of descriptions
       * for all types of phone numbers. If any element is missing in the
       * description of a specific type in the XML file, the element will inherit
       * from its counterpart in the general_desc. Every locale is assumed to have
       * fixed line and mobile numbers - if these types are missing in the
       * PhoneNumberMetadata XML file, they will inherit all fields from the
       * general_desc. For all other types that are generally relevant to normal
       * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
       * file, it will be given a national_number_pattern of "NA" and a
       * possible_number_pattern of "NA".
       * </pre>
       */
      public Builder setGeneralDesc(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        generalDesc_ = value;

        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
       *
       * <pre>
       * The general_desc contains information which is a superset of descriptions
       * for all types of phone numbers. If any element is missing in the
       * description of a specific type in the XML file, the element will inherit
       * from its counterpart in the general_desc. Every locale is assumed to have
       * fixed line and mobile numbers - if these types are missing in the
       * PhoneNumberMetadata XML file, they will inherit all fields from the
       * general_desc. For all other types that are generally relevant to normal
       * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
       * file, it will be given a national_number_pattern of "NA" and a
       * possible_number_pattern of "NA".
       * </pre>
       */
      public Builder setGeneralDesc(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        generalDesc_ = builderForValue.build();

        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
       *
       * <pre>
       * The general_desc contains information which is a superset of descriptions
       * for all types of phone numbers. If any element is missing in the
       * description of a specific type in the XML file, the element will inherit
       * from its counterpart in the general_desc. Every locale is assumed to have
       * fixed line and mobile numbers - if these types are missing in the
       * PhoneNumberMetadata XML file, they will inherit all fields from the
       * general_desc. For all other types that are generally relevant to normal
       * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
       * file, it will be given a national_number_pattern of "NA" and a
       * possible_number_pattern of "NA".
       * </pre>
       */
      public Builder mergeGeneralDesc(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000001) == 0x00000001) &&
            generalDesc_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          generalDesc_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(generalDesc_).mergeFrom(value).buildPartial();
        } else {
          generalDesc_ = value;
        }

        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc general_desc = 1;</code>
       *
       * <pre>
       * The general_desc contains information which is a superset of descriptions
       * for all types of phone numbers. If any element is missing in the
       * description of a specific type in the XML file, the element will inherit
       * from its counterpart in the general_desc. Every locale is assumed to have
       * fixed line and mobile numbers - if these types are missing in the
       * PhoneNumberMetadata XML file, they will inherit all fields from the
       * general_desc. For all other types that are generally relevant to normal
       * phone numbers, if the whole type is missing in the PhoneNumberMetadata XML
       * file, it will be given a national_number_pattern of "NA" and a
       * possible_number_pattern of "NA".
       * </pre>
       */
      public Builder clearGeneralDesc() {
        generalDesc_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc fixedLine_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
       */
      public boolean hasFixedLine() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getFixedLine() {
        return fixedLine_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
       */
      public Builder setFixedLine(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        fixedLine_ = value;

        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
       */
      public Builder setFixedLine(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        fixedLine_ = builderForValue.build();

        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
       */
      public Builder mergeFixedLine(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000002) == 0x00000002) &&
            fixedLine_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          fixedLine_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(fixedLine_).mergeFrom(value).buildPartial();
        } else {
          fixedLine_ = value;
        }

        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc fixed_line = 2;</code>
       */
      public Builder clearFixedLine() {
        fixedLine_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc mobile_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
       */
      public boolean hasMobile() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getMobile() {
        return mobile_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
       */
      public Builder setMobile(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        mobile_ = value;

        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
       */
      public Builder setMobile(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        mobile_ = builderForValue.build();

        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
       */
      public Builder mergeMobile(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000004) == 0x00000004) &&
            mobile_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          mobile_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(mobile_).mergeFrom(value).buildPartial();
        } else {
          mobile_ = value;
        }

        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc mobile = 3;</code>
       */
      public Builder clearMobile() {
        mobile_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc tollFree_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
       */
      public boolean hasTollFree() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getTollFree() {
        return tollFree_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
       */
      public Builder setTollFree(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        tollFree_ = value;

        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
       */
      public Builder setTollFree(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        tollFree_ = builderForValue.build();

        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
       */
      public Builder mergeTollFree(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000008) == 0x00000008) &&
            tollFree_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          tollFree_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(tollFree_).mergeFrom(value).buildPartial();
        } else {
          tollFree_ = value;
        }

        bitField0_ |= 0x00000008;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc toll_free = 4;</code>
       */
      public Builder clearTollFree() {
        tollFree_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000008);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc premiumRate_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
       */
      public boolean hasPremiumRate() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPremiumRate() {
        return premiumRate_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
       */
      public Builder setPremiumRate(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        premiumRate_ = value;

        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
       */
      public Builder setPremiumRate(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        premiumRate_ = builderForValue.build();

        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
       */
      public Builder mergePremiumRate(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000010) == 0x00000010) &&
            premiumRate_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          premiumRate_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(premiumRate_).mergeFrom(value).buildPartial();
        } else {
          premiumRate_ = value;
        }

        bitField0_ |= 0x00000010;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc premium_rate = 5;</code>
       */
      public Builder clearPremiumRate() {
        premiumRate_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc sharedCost_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
       */
      public boolean hasSharedCost() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getSharedCost() {
        return sharedCost_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
       */
      public Builder setSharedCost(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        sharedCost_ = value;

        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
       */
      public Builder setSharedCost(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        sharedCost_ = builderForValue.build();

        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
       */
      public Builder mergeSharedCost(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000020) == 0x00000020) &&
            sharedCost_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          sharedCost_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(sharedCost_).mergeFrom(value).buildPartial();
        } else {
          sharedCost_ = value;
        }

        bitField0_ |= 0x00000020;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc shared_cost = 6;</code>
       */
      public Builder clearSharedCost() {
        sharedCost_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000020);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc personalNumber_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
       */
      public boolean hasPersonalNumber() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPersonalNumber() {
        return personalNumber_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
       */
      public Builder setPersonalNumber(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        personalNumber_ = value;

        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
       */
      public Builder setPersonalNumber(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        personalNumber_ = builderForValue.build();

        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
       */
      public Builder mergePersonalNumber(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000040) == 0x00000040) &&
            personalNumber_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          personalNumber_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(personalNumber_).mergeFrom(value).buildPartial();
        } else {
          personalNumber_ = value;
        }

        bitField0_ |= 0x00000040;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc personal_number = 7;</code>
       */
      public Builder clearPersonalNumber() {
        personalNumber_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc voip_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
       */
      public boolean hasVoip() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getVoip() {
        return voip_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
       */
      public Builder setVoip(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        voip_ = value;

        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
       */
      public Builder setVoip(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        voip_ = builderForValue.build();

        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
       */
      public Builder mergeVoip(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000080) == 0x00000080) &&
            voip_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          voip_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(voip_).mergeFrom(value).buildPartial();
        } else {
          voip_ = value;
        }

        bitField0_ |= 0x00000080;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voip = 8;</code>
       */
      public Builder clearVoip() {
        voip_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000080);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc pager_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
       */
      public boolean hasPager() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getPager() {
        return pager_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
       */
      public Builder setPager(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        pager_ = value;

        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
       */
      public Builder setPager(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        pager_ = builderForValue.build();

        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
       */
      public Builder mergePager(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000100) == 0x00000100) &&
            pager_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          pager_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(pager_).mergeFrom(value).buildPartial();
        } else {
          pager_ = value;
        }

        bitField0_ |= 0x00000100;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc pager = 21;</code>
       */
      public Builder clearPager() {
        pager_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc uan_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
       */
      public boolean hasUan() {
        return ((bitField0_ & 0x00000200) == 0x00000200);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getUan() {
        return uan_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
       */
      public Builder setUan(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        uan_ = value;

        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
       */
      public Builder setUan(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        uan_ = builderForValue.build();

        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
       */
      public Builder mergeUan(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000200) == 0x00000200) &&
            uan_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          uan_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(uan_).mergeFrom(value).buildPartial();
        } else {
          uan_ = value;
        }

        bitField0_ |= 0x00000200;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc uan = 25;</code>
       */
      public Builder clearUan() {
        uan_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000200);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc emergency_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
       */
      public boolean hasEmergency() {
        return ((bitField0_ & 0x00000400) == 0x00000400);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getEmergency() {
        return emergency_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
       */
      public Builder setEmergency(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        emergency_ = value;

        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
       */
      public Builder setEmergency(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        emergency_ = builderForValue.build();

        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
       */
      public Builder mergeEmergency(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000400) == 0x00000400) &&
            emergency_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          emergency_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(emergency_).mergeFrom(value).buildPartial();
        } else {
          emergency_ = value;
        }

        bitField0_ |= 0x00000400;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc emergency = 27;</code>
       */
      public Builder clearEmergency() {
        emergency_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000400);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc voicemail_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
       */
      public boolean hasVoicemail() {
        return ((bitField0_ & 0x00000800) == 0x00000800);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getVoicemail() {
        return voicemail_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
       */
      public Builder setVoicemail(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        voicemail_ = value;

        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
       */
      public Builder setVoicemail(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        voicemail_ = builderForValue.build();

        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
       */
      public Builder mergeVoicemail(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00000800) == 0x00000800) &&
            voicemail_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          voicemail_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(voicemail_).mergeFrom(value).buildPartial();
        } else {
          voicemail_ = value;
        }

        bitField0_ |= 0x00000800;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc voicemail = 28;</code>
       */
      public Builder clearVoicemail() {
        voicemail_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00000800);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc shortCode_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
       */
      public boolean hasShortCode() {
        return ((bitField0_ & 0x00001000) == 0x00001000);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getShortCode() {
        return shortCode_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
       */
      public Builder setShortCode(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        shortCode_ = value;

        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
       */
      public Builder setShortCode(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        shortCode_ = builderForValue.build();

        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
       */
      public Builder mergeShortCode(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00001000) == 0x00001000) &&
            shortCode_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          shortCode_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(shortCode_).mergeFrom(value).buildPartial();
        } else {
          shortCode_ = value;
        }

        bitField0_ |= 0x00001000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc short_code = 29;</code>
       */
      public Builder clearShortCode() {
        shortCode_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00001000);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc standardRate_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
       */
      public boolean hasStandardRate() {
        return ((bitField0_ & 0x00002000) == 0x00002000);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getStandardRate() {
        return standardRate_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
       */
      public Builder setStandardRate(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        standardRate_ = value;

        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
       */
      public Builder setStandardRate(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        standardRate_ = builderForValue.build();

        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
       */
      public Builder mergeStandardRate(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00002000) == 0x00002000) &&
            standardRate_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          standardRate_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(standardRate_).mergeFrom(value).buildPartial();
        } else {
          standardRate_ = value;
        }

        bitField0_ |= 0x00002000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc standard_rate = 30;</code>
       */
      public Builder clearStandardRate() {
        standardRate_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00002000);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc carrierSpecific_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
       */
      public boolean hasCarrierSpecific() {
        return ((bitField0_ & 0x00004000) == 0x00004000);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getCarrierSpecific() {
        return carrierSpecific_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
       */
      public Builder setCarrierSpecific(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        carrierSpecific_ = value;

        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
       */
      public Builder setCarrierSpecific(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        carrierSpecific_ = builderForValue.build();

        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
       */
      public Builder mergeCarrierSpecific(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00004000) == 0x00004000) &&
            carrierSpecific_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          carrierSpecific_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(carrierSpecific_).mergeFrom(value).buildPartial();
        } else {
          carrierSpecific_ = value;
        }

        bitField0_ |= 0x00004000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc carrier_specific = 31;</code>
       */
      public Builder clearCarrierSpecific() {
        carrierSpecific_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00004000);
        return this;
      }

      private com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc noInternationalDialling_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
       *
       * <pre>
       * The rules here distinguish the numbers that are only able to be dialled
       * nationally.
       * </pre>
       */
      public boolean hasNoInternationalDialling() {
        return ((bitField0_ & 0x00008000) == 0x00008000);
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
       *
       * <pre>
       * The rules here distinguish the numbers that are only able to be dialled
       * nationally.
       * </pre>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc getNoInternationalDialling() {
        return noInternationalDialling_;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
       *
       * <pre>
       * The rules here distinguish the numbers that are only able to be dialled
       * nationally.
       * </pre>
       */
      public Builder setNoInternationalDialling(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (value == null) {
          throw new NullPointerException();
        }
        noInternationalDialling_ = value;

        bitField0_ |= 0x00008000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
       *
       * <pre>
       * The rules here distinguish the numbers that are only able to be dialled
       * nationally.
       * </pre>
       */
      public Builder setNoInternationalDialling(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.Builder builderForValue) {
        noInternationalDialling_ = builderForValue.build();

        bitField0_ |= 0x00008000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
       *
       * <pre>
       * The rules here distinguish the numbers that are only able to be dialled
       * nationally.
       * </pre>
       */
      public Builder mergeNoInternationalDialling(com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc value) {
        if (((bitField0_ & 0x00008000) == 0x00008000) &&
            noInternationalDialling_ != com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance()) {
          noInternationalDialling_ =
            com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.newBuilder(noInternationalDialling_).mergeFrom(value).buildPartial();
        } else {
          noInternationalDialling_ = value;
        }

        bitField0_ |= 0x00008000;
        return this;
      }
      /**
       * <code>optional .i18n.phonenumbers.PhoneNumberDesc no_international_dialling = 24;</code>
       *
       * <pre>
       * The rules here distinguish the numbers that are only able to be dialled
       * nationally.
       * </pre>
       */
      public Builder clearNoInternationalDialling() {
        noInternationalDialling_ = com.google.i18n.phonenumbers.Phonemetadata.PhoneNumberDesc.getDefaultInstance();

        bitField0_ = (bitField0_ & ~0x00008000);
        return this;
      }

      private java.lang.Object id_ = "";
      /**
       * <code>required string id = 9;</code>
       *
       * <pre>
       * The ISO 3166-1 alpha-2 representation of a country/region, with the
       * exception of "country calling codes" used for non-geographical entities,
       * such as Universal International Toll Free Number (+800). These are all
       * given the ID "001", since this is the numeric region code for the world
       * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
       * </pre>
       */
      public boolean hasId() {
        return ((bitField0_ & 0x00010000) == 0x00010000);
      }
      /**
       * <code>required string id = 9;</code>
       *
       * <pre>
       * The ISO 3166-1 alpha-2 representation of a country/region, with the
       * exception of "country calling codes" used for non-geographical entities,
       * such as Universal International Toll Free Number (+800). These are all
       * given the ID "001", since this is the numeric region code for the world
       * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
       * </pre>
       */
      public java.lang.String getId() {
        java.lang.Object ref = id_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            id_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>required string id = 9;</code>
       *
       * <pre>
       * The ISO 3166-1 alpha-2 representation of a country/region, with the
       * exception of "country calling codes" used for non-geographical entities,
       * such as Universal International Toll Free Number (+800). These are all
       * given the ID "001", since this is the numeric region code for the world
       * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
       * </pre>
       */
      public com.google.protobuf.ByteString
          getIdBytes() {
        java.lang.Object ref = id_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          id_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>required string id = 9;</code>
       *
       * <pre>
       * The ISO 3166-1 alpha-2 representation of a country/region, with the
       * exception of "country calling codes" used for non-geographical entities,
       * such as Universal International Toll Free Number (+800). These are all
       * given the ID "001", since this is the numeric region code for the world
       * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
       * </pre>
       */
      public Builder setId(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00010000;
        id_ = value;
        
        return this;
      }
      /**
       * <code>required string id = 9;</code>
       *
       * <pre>
       * The ISO 3166-1 alpha-2 representation of a country/region, with the
       * exception of "country calling codes" used for non-geographical entities,
       * such as Universal International Toll Free Number (+800). These are all
       * given the ID "001", since this is the numeric region code for the world
       * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
       * </pre>
       */
      public Builder clearId() {
        bitField0_ = (bitField0_ & ~0x00010000);
        id_ = getDefaultInstance().getId();
        
        return this;
      }
      /**
       * <code>required string id = 9;</code>
       *
       * <pre>
       * The ISO 3166-1 alpha-2 representation of a country/region, with the
       * exception of "country calling codes" used for non-geographical entities,
       * such as Universal International Toll Free Number (+800). These are all
       * given the ID "001", since this is the numeric region code for the world
       * according to UN M.49: http://en.wikipedia.org/wiki/UN_M.49
       * </pre>
       */
      public Builder setIdBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00010000;
        id_ = value;
        
        return this;
      }

      private int countryCode_ ;
      /**
       * <code>optional int32 country_code = 10;</code>
       *
       * <pre>
       * The country calling code that one would dial from overseas when trying to
       * dial a phone number in this country. For example, this would be "64" for
       * New Zealand.
       * </pre>
       */
      public boolean hasCountryCode() {
        return ((bitField0_ & 0x00020000) == 0x00020000);
      }
      /**
       * <code>optional int32 country_code = 10;</code>
       *
       * <pre>
       * The country calling code that one would dial from overseas when trying to
       * dial a phone number in this country. For example, this would be "64" for
       * New Zealand.
       * </pre>
       */
      public int getCountryCode() {
        return countryCode_;
      }
      /**
       * <code>optional int32 country_code = 10;</code>
       *
       * <pre>
       * The country calling code that one would dial from overseas when trying to
       * dial a phone number in this country. For example, this would be "64" for
       * New Zealand.
       * </pre>
       */
      public Builder setCountryCode(int value) {
        bitField0_ |= 0x00020000;
        countryCode_ = value;
        
        return this;
      }
      /**
       * <code>optional int32 country_code = 10;</code>
       *
       * <pre>
       * The country calling code that one would dial from overseas when trying to
       * dial a phone number in this country. For example, this would be "64" for
       * New Zealand.
       * </pre>
       */
      public Builder clearCountryCode() {
        bitField0_ = (bitField0_ & ~0x00020000);
        countryCode_ = 0;
        
        return this;
      }

      private java.lang.Object internationalPrefix_ = "";
      /**
       * <code>optional string international_prefix = 11;</code>
       *
       * <pre>
       * The international_prefix of country A is the number that needs to be
       * dialled from country A to another country (country B). This is followed
       * by the country code for country B. Note that some countries may have more
       * than one international prefix, and for those cases, a regular expression
       * matching the international prefixes will be stored in this field.
       * </pre>
       */
      public boolean hasInternationalPrefix() {
        return ((bitField0_ & 0x00040000) == 0x00040000);
      }
      /**
       * <code>optional string international_prefix = 11;</code>
       *
       * <pre>
       * The international_prefix of country A is the number that needs to be
       * dialled from country A to another country (country B). This is followed
       * by the country code for country B. Note that some countries may have more
       * than one international prefix, and for those cases, a regular expression
       * matching the international prefixes will be stored in this field.
       * </pre>
       */
      public java.lang.String getInternationalPrefix() {
        java.lang.Object ref = internationalPrefix_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            internationalPrefix_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string international_prefix = 11;</code>
       *
       * <pre>
       * The international_prefix of country A is the number that needs to be
       * dialled from country A to another country (country B). This is followed
       * by the country code for country B. Note that some countries may have more
       * than one international prefix, and for those cases, a regular expression
       * matching the international prefixes will be stored in this field.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getInternationalPrefixBytes() {
        java.lang.Object ref = internationalPrefix_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          internationalPrefix_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string international_prefix = 11;</code>
       *
       * <pre>
       * The international_prefix of country A is the number that needs to be
       * dialled from country A to another country (country B). This is followed
       * by the country code for country B. Note that some countries may have more
       * than one international prefix, and for those cases, a regular expression
       * matching the international prefixes will be stored in this field.
       * </pre>
       */
      public Builder setInternationalPrefix(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00040000;
        internationalPrefix_ = value;
        
        return this;
      }
      /**
       * <code>optional string international_prefix = 11;</code>
       *
       * <pre>
       * The international_prefix of country A is the number that needs to be
       * dialled from country A to another country (country B). This is followed
       * by the country code for country B. Note that some countries may have more
       * than one international prefix, and for those cases, a regular expression
       * matching the international prefixes will be stored in this field.
       * </pre>
       */
      public Builder clearInternationalPrefix() {
        bitField0_ = (bitField0_ & ~0x00040000);
        internationalPrefix_ = getDefaultInstance().getInternationalPrefix();
        
        return this;
      }
      /**
       * <code>optional string international_prefix = 11;</code>
       *
       * <pre>
       * The international_prefix of country A is the number that needs to be
       * dialled from country A to another country (country B). This is followed
       * by the country code for country B. Note that some countries may have more
       * than one international prefix, and for those cases, a regular expression
       * matching the international prefixes will be stored in this field.
       * </pre>
       */
      public Builder setInternationalPrefixBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00040000;
        internationalPrefix_ = value;
        
        return this;
      }

      private java.lang.Object preferredInternationalPrefix_ = "";
      /**
       * <code>optional string preferred_international_prefix = 17;</code>
       *
       * <pre>
       * If more than one international prefix is present, a preferred prefix can
       * be specified here for out-of-country formatting purposes. If this field is
       * not present, and multiple international prefixes are present, then "+"
       * will be used instead.
       * </pre>
       */
      public boolean hasPreferredInternationalPrefix() {
        return ((bitField0_ & 0x00080000) == 0x00080000);
      }
      /**
       * <code>optional string preferred_international_prefix = 17;</code>
       *
       * <pre>
       * If more than one international prefix is present, a preferred prefix can
       * be specified here for out-of-country formatting purposes. If this field is
       * not present, and multiple international prefixes are present, then "+"
       * will be used instead.
       * </pre>
       */
      public java.lang.String getPreferredInternationalPrefix() {
        java.lang.Object ref = preferredInternationalPrefix_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            preferredInternationalPrefix_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string preferred_international_prefix = 17;</code>
       *
       * <pre>
       * If more than one international prefix is present, a preferred prefix can
       * be specified here for out-of-country formatting purposes. If this field is
       * not present, and multiple international prefixes are present, then "+"
       * will be used instead.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getPreferredInternationalPrefixBytes() {
        java.lang.Object ref = preferredInternationalPrefix_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          preferredInternationalPrefix_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string preferred_international_prefix = 17;</code>
       *
       * <pre>
       * If more than one international prefix is present, a preferred prefix can
       * be specified here for out-of-country formatting purposes. If this field is
       * not present, and multiple international prefixes are present, then "+"
       * will be used instead.
       * </pre>
       */
      public Builder setPreferredInternationalPrefix(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00080000;
        preferredInternationalPrefix_ = value;
        
        return this;
      }
      /**
       * <code>optional string preferred_international_prefix = 17;</code>
       *
       * <pre>
       * If more than one international prefix is present, a preferred prefix can
       * be specified here for out-of-country formatting purposes. If this field is
       * not present, and multiple international prefixes are present, then "+"
       * will be used instead.
       * </pre>
       */
      public Builder clearPreferredInternationalPrefix() {
        bitField0_ = (bitField0_ & ~0x00080000);
        preferredInternationalPrefix_ = getDefaultInstance().getPreferredInternationalPrefix();
        
        return this;
      }
      /**
       * <code>optional string preferred_international_prefix = 17;</code>
       *
       * <pre>
       * If more than one international prefix is present, a preferred prefix can
       * be specified here for out-of-country formatting purposes. If this field is
       * not present, and multiple international prefixes are present, then "+"
       * will be used instead.
       * </pre>
       */
      public Builder setPreferredInternationalPrefixBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00080000;
        preferredInternationalPrefix_ = value;
        
        return this;
      }

      private java.lang.Object nationalPrefix_ = "";
      /**
       * <code>optional string national_prefix = 12;</code>
       *
       * <pre>
       * The national prefix of country A is the number that needs to be dialled
       * before the national significant number when dialling internally. This
       * would not be dialled when dialling internationally. For example, in New
       * Zealand, the number that would be locally dialled as 09 345 3456 would be
       * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
       * prefix.
       * </pre>
       */
      public boolean hasNationalPrefix() {
        return ((bitField0_ & 0x00100000) == 0x00100000);
      }
      /**
       * <code>optional string national_prefix = 12;</code>
       *
       * <pre>
       * The national prefix of country A is the number that needs to be dialled
       * before the national significant number when dialling internally. This
       * would not be dialled when dialling internationally. For example, in New
       * Zealand, the number that would be locally dialled as 09 345 3456 would be
       * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
       * prefix.
       * </pre>
       */
      public java.lang.String getNationalPrefix() {
        java.lang.Object ref = nationalPrefix_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            nationalPrefix_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string national_prefix = 12;</code>
       *
       * <pre>
       * The national prefix of country A is the number that needs to be dialled
       * before the national significant number when dialling internally. This
       * would not be dialled when dialling internationally. For example, in New
       * Zealand, the number that would be locally dialled as 09 345 3456 would be
       * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
       * prefix.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getNationalPrefixBytes() {
        java.lang.Object ref = nationalPrefix_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nationalPrefix_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string national_prefix = 12;</code>
       *
       * <pre>
       * The national prefix of country A is the number that needs to be dialled
       * before the national significant number when dialling internally. This
       * would not be dialled when dialling internationally. For example, in New
       * Zealand, the number that would be locally dialled as 09 345 3456 would be
       * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
       * prefix.
       * </pre>
       */
      public Builder setNationalPrefix(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00100000;
        nationalPrefix_ = value;
        
        return this;
      }
      /**
       * <code>optional string national_prefix = 12;</code>
       *
       * <pre>
       * The national prefix of country A is the number that needs to be dialled
       * before the national significant number when dialling internally. This
       * would not be dialled when dialling internationally. For example, in New
       * Zealand, the number that would be locally dialled as 09 345 3456 would be
       * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
       * prefix.
       * </pre>
       */
      public Builder clearNationalPrefix() {
        bitField0_ = (bitField0_ & ~0x00100000);
        nationalPrefix_ = getDefaultInstance().getNationalPrefix();
        
        return this;
      }
      /**
       * <code>optional string national_prefix = 12;</code>
       *
       * <pre>
       * The national prefix of country A is the number that needs to be dialled
       * before the national significant number when dialling internally. This
       * would not be dialled when dialling internationally. For example, in New
       * Zealand, the number that would be locally dialled as 09 345 3456 would be
       * dialled from overseas as +64 9 345 3456. In this case, 0 is the national
       * prefix.
       * </pre>
       */
      public Builder setNationalPrefixBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00100000;
        nationalPrefix_ = value;
        
        return this;
      }

      private java.lang.Object preferredExtnPrefix_ = "";
      /**
       * <code>optional string preferred_extn_prefix = 13;</code>
       *
       * <pre>
       * The preferred prefix when specifying an extension in this country. This is
       * used for formatting only, and if this is not specified, a suitable default
       * should be used instead. For example, if you wanted extensions to be
       * formatted in the following way:
       * 1 (365) 345 445 ext. 2345
       * " ext. "  should be the preferred extension prefix.
       * </pre>
       */
      public boolean hasPreferredExtnPrefix() {
        return ((bitField0_ & 0x00200000) == 0x00200000);
      }
      /**
       * <code>optional string preferred_extn_prefix = 13;</code>
       *
       * <pre>
       * The preferred prefix when specifying an extension in this country. This is
       * used for formatting only, and if this is not specified, a suitable default
       * should be used instead. For example, if you wanted extensions to be
       * formatted in the following way:
       * 1 (365) 345 445 ext. 2345
       * " ext. "  should be the preferred extension prefix.
       * </pre>
       */
      public java.lang.String getPreferredExtnPrefix() {
        java.lang.Object ref = preferredExtnPrefix_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            preferredExtnPrefix_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string preferred_extn_prefix = 13;</code>
       *
       * <pre>
       * The preferred prefix when specifying an extension in this country. This is
       * used for formatting only, and if this is not specified, a suitable default
       * should be used instead. For example, if you wanted extensions to be
       * formatted in the following way:
       * 1 (365) 345 445 ext. 2345
       * " ext. "  should be the preferred extension prefix.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getPreferredExtnPrefixBytes() {
        java.lang.Object ref = preferredExtnPrefix_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          preferredExtnPrefix_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string preferred_extn_prefix = 13;</code>
       *
       * <pre>
       * The preferred prefix when specifying an extension in this country. This is
       * used for formatting only, and if this is not specified, a suitable default
       * should be used instead. For example, if you wanted extensions to be
       * formatted in the following way:
       * 1 (365) 345 445 ext. 2345
       * " ext. "  should be the preferred extension prefix.
       * </pre>
       */
      public Builder setPreferredExtnPrefix(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00200000;
        preferredExtnPrefix_ = value;
        
        return this;
      }
      /**
       * <code>optional string preferred_extn_prefix = 13;</code>
       *
       * <pre>
       * The preferred prefix when specifying an extension in this country. This is
       * used for formatting only, and if this is not specified, a suitable default
       * should be used instead. For example, if you wanted extensions to be
       * formatted in the following way:
       * 1 (365) 345 445 ext. 2345
       * " ext. "  should be the preferred extension prefix.
       * </pre>
       */
      public Builder clearPreferredExtnPrefix() {
        bitField0_ = (bitField0_ & ~0x00200000);
        preferredExtnPrefix_ = getDefaultInstance().getPreferredExtnPrefix();
        
        return this;
      }
      /**
       * <code>optional string preferred_extn_prefix = 13;</code>
       *
       * <pre>
       * The preferred prefix when specifying an extension in this country. This is
       * used for formatting only, and if this is not specified, a suitable default
       * should be used instead. For example, if you wanted extensions to be
       * formatted in the following way:
       * 1 (365) 345 445 ext. 2345
       * " ext. "  should be the preferred extension prefix.
       * </pre>
       */
      public Builder setPreferredExtnPrefixBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00200000;
        preferredExtnPrefix_ = value;
        
        return this;
      }

      private java.lang.Object nationalPrefixForParsing_ = "";
      /**
       * <code>optional string national_prefix_for_parsing = 15;</code>
       *
       * <pre>
       * This field is used for cases where the national prefix of a country
       * contains a carrier selection code, and is written in the form of a
       * regular expression. For example, to dial the number 2222-2222 in
       * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
       * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
       * only other possible carrier selection code is 32, the field will
       * contain "03[12]".
       * When it is missing from the XML file, this field inherits the value of
       * national_prefix, if that is present.
       * </pre>
       */
      public boolean hasNationalPrefixForParsing() {
        return ((bitField0_ & 0x00400000) == 0x00400000);
      }
      /**
       * <code>optional string national_prefix_for_parsing = 15;</code>
       *
       * <pre>
       * This field is used for cases where the national prefix of a country
       * contains a carrier selection code, and is written in the form of a
       * regular expression. For example, to dial the number 2222-2222 in
       * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
       * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
       * only other possible carrier selection code is 32, the field will
       * contain "03[12]".
       * When it is missing from the XML file, this field inherits the value of
       * national_prefix, if that is present.
       * </pre>
       */
      public java.lang.String getNationalPrefixForParsing() {
        java.lang.Object ref = nationalPrefixForParsing_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            nationalPrefixForParsing_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string national_prefix_for_parsing = 15;</code>
       *
       * <pre>
       * This field is used for cases where the national prefix of a country
       * contains a carrier selection code, and is written in the form of a
       * regular expression. For example, to dial the number 2222-2222 in
       * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
       * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
       * only other possible carrier selection code is 32, the field will
       * contain "03[12]".
       * When it is missing from the XML file, this field inherits the value of
       * national_prefix, if that is present.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getNationalPrefixForParsingBytes() {
        java.lang.Object ref = nationalPrefixForParsing_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nationalPrefixForParsing_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string national_prefix_for_parsing = 15;</code>
       *
       * <pre>
       * This field is used for cases where the national prefix of a country
       * contains a carrier selection code, and is written in the form of a
       * regular expression. For example, to dial the number 2222-2222 in
       * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
       * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
       * only other possible carrier selection code is 32, the field will
       * contain "03[12]".
       * When it is missing from the XML file, this field inherits the value of
       * national_prefix, if that is present.
       * </pre>
       */
      public Builder setNationalPrefixForParsing(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00400000;
        nationalPrefixForParsing_ = value;
        
        return this;
      }
      /**
       * <code>optional string national_prefix_for_parsing = 15;</code>
       *
       * <pre>
       * This field is used for cases where the national prefix of a country
       * contains a carrier selection code, and is written in the form of a
       * regular expression. For example, to dial the number 2222-2222 in
       * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
       * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
       * only other possible carrier selection code is 32, the field will
       * contain "03[12]".
       * When it is missing from the XML file, this field inherits the value of
       * national_prefix, if that is present.
       * </pre>
       */
      public Builder clearNationalPrefixForParsing() {
        bitField0_ = (bitField0_ & ~0x00400000);
        nationalPrefixForParsing_ = getDefaultInstance().getNationalPrefixForParsing();
        
        return this;
      }
      /**
       * <code>optional string national_prefix_for_parsing = 15;</code>
       *
       * <pre>
       * This field is used for cases where the national prefix of a country
       * contains a carrier selection code, and is written in the form of a
       * regular expression. For example, to dial the number 2222-2222 in
       * Fortaleza, Brazil (area code 85) using the long distance carrier Oi
       * (selection code 31), one would dial 0 31 85 2222 2222. Assuming the
       * only other possible carrier selection code is 32, the field will
       * contain "03[12]".
       * When it is missing from the XML file, this field inherits the value of
       * national_prefix, if that is present.
       * </pre>
       */
      public Builder setNationalPrefixForParsingBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00400000;
        nationalPrefixForParsing_ = value;
        
        return this;
      }

      private java.lang.Object nationalPrefixTransformRule_ = "";
      /**
       * <code>optional string national_prefix_transform_rule = 16;</code>
       *
       * <pre>
       * This field is only populated and used under very rare situations.
       * For example, mobile numbers in Argentina are written in two completely
       * different ways when dialed in-country and out-of-country
       * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
       * This field is used together with national_prefix_for_parsing to transform
       * the number into a particular representation for storing in the phonenumber
       * proto buffer in those rare cases.
       * </pre>
       */
      public boolean hasNationalPrefixTransformRule() {
        return ((bitField0_ & 0x00800000) == 0x00800000);
      }
      /**
       * <code>optional string national_prefix_transform_rule = 16;</code>
       *
       * <pre>
       * This field is only populated and used under very rare situations.
       * For example, mobile numbers in Argentina are written in two completely
       * different ways when dialed in-country and out-of-country
       * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
       * This field is used together with national_prefix_for_parsing to transform
       * the number into a particular representation for storing in the phonenumber
       * proto buffer in those rare cases.
       * </pre>
       */
      public java.lang.String getNationalPrefixTransformRule() {
        java.lang.Object ref = nationalPrefixTransformRule_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            nationalPrefixTransformRule_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string national_prefix_transform_rule = 16;</code>
       *
       * <pre>
       * This field is only populated and used under very rare situations.
       * For example, mobile numbers in Argentina are written in two completely
       * different ways when dialed in-country and out-of-country
       * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
       * This field is used together with national_prefix_for_parsing to transform
       * the number into a particular representation for storing in the phonenumber
       * proto buffer in those rare cases.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getNationalPrefixTransformRuleBytes() {
        java.lang.Object ref = nationalPrefixTransformRule_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          nationalPrefixTransformRule_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string national_prefix_transform_rule = 16;</code>
       *
       * <pre>
       * This field is only populated and used under very rare situations.
       * For example, mobile numbers in Argentina are written in two completely
       * different ways when dialed in-country and out-of-country
       * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
       * This field is used together with national_prefix_for_parsing to transform
       * the number into a particular representation for storing in the phonenumber
       * proto buffer in those rare cases.
       * </pre>
       */
      public Builder setNationalPrefixTransformRule(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00800000;
        nationalPrefixTransformRule_ = value;
        
        return this;
      }
      /**
       * <code>optional string national_prefix_transform_rule = 16;</code>
       *
       * <pre>
       * This field is only populated and used under very rare situations.
       * For example, mobile numbers in Argentina are written in two completely
       * different ways when dialed in-country and out-of-country
       * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
       * This field is used together with national_prefix_for_parsing to transform
       * the number into a particular representation for storing in the phonenumber
       * proto buffer in those rare cases.
       * </pre>
       */
      public Builder clearNationalPrefixTransformRule() {
        bitField0_ = (bitField0_ & ~0x00800000);
        nationalPrefixTransformRule_ = getDefaultInstance().getNationalPrefixTransformRule();
        
        return this;
      }
      /**
       * <code>optional string national_prefix_transform_rule = 16;</code>
       *
       * <pre>
       * This field is only populated and used under very rare situations.
       * For example, mobile numbers in Argentina are written in two completely
       * different ways when dialed in-country and out-of-country
       * (e.g. 0343 15 555 1212 is exactly the same number as +54 9 343 555 1212).
       * This field is used together with national_prefix_for_parsing to transform
       * the number into a particular representation for storing in the phonenumber
       * proto buffer in those rare cases.
       * </pre>
       */
      public Builder setNationalPrefixTransformRuleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00800000;
        nationalPrefixTransformRule_ = value;
        
        return this;
      }

      private boolean sameMobileAndFixedLinePattern_ ;
      /**
       * <code>optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];</code>
       *
       * <pre>
       * Specifies whether the mobile and fixed-line patterns are the same or not.
       * This is used to speed up determining phone number type in countries where
       * these two types of phone numbers can never be distinguished.
       * </pre>
       */
      public boolean hasSameMobileAndFixedLinePattern() {
        return ((bitField0_ & 0x01000000) == 0x01000000);
      }
      /**
       * <code>optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];</code>
       *
       * <pre>
       * Specifies whether the mobile and fixed-line patterns are the same or not.
       * This is used to speed up determining phone number type in countries where
       * these two types of phone numbers can never be distinguished.
       * </pre>
       */
      public boolean getSameMobileAndFixedLinePattern() {
        return sameMobileAndFixedLinePattern_;
      }
      /**
       * <code>optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];</code>
       *
       * <pre>
       * Specifies whether the mobile and fixed-line patterns are the same or not.
       * This is used to speed up determining phone number type in countries where
       * these two types of phone numbers can never be distinguished.
       * </pre>
       */
      public Builder setSameMobileAndFixedLinePattern(boolean value) {
        bitField0_ |= 0x01000000;
        sameMobileAndFixedLinePattern_ = value;
        
        return this;
      }
      /**
       * <code>optional bool same_mobile_and_fixed_line_pattern = 18 [default = false];</code>
       *
       * <pre>
       * Specifies whether the mobile and fixed-line patterns are the same or not.
       * This is used to speed up determining phone number type in countries where
       * these two types of phone numbers can never be distinguished.
       * </pre>
       */
      public Builder clearSameMobileAndFixedLinePattern() {
        bitField0_ = (bitField0_ & ~0x01000000);
        sameMobileAndFixedLinePattern_ = false;
        
        return this;
      }

      private java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> numberFormat_ =
        java.util.Collections.emptyList();
      private void ensureNumberFormatIsMutable() {
        if (!((bitField0_ & 0x02000000) == 0x02000000)) {
          numberFormat_ = new java.util.ArrayList<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat>(numberFormat_);
          bitField0_ |= 0x02000000;
         }
      }

      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> getNumberFormatList() {
        return java.util.Collections.unmodifiableList(numberFormat_);
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public int getNumberFormatCount() {
        return numberFormat_.size();
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.NumberFormat getNumberFormat(int index) {
        return numberFormat_.get(index);
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder setNumberFormat(
          int index, com.google.i18n.phonenumbers.Phonemetadata.NumberFormat value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureNumberFormatIsMutable();
        numberFormat_.set(index, value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder setNumberFormat(
          int index, com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.Builder builderForValue) {
        ensureNumberFormatIsMutable();
        numberFormat_.set(index, builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder addNumberFormat(com.google.i18n.phonenumbers.Phonemetadata.NumberFormat value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureNumberFormatIsMutable();
        numberFormat_.add(value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder addNumberFormat(
          int index, com.google.i18n.phonenumbers.Phonemetadata.NumberFormat value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureNumberFormatIsMutable();
        numberFormat_.add(index, value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder addNumberFormat(
          com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.Builder builderForValue) {
        ensureNumberFormatIsMutable();
        numberFormat_.add(builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder addNumberFormat(
          int index, com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.Builder builderForValue) {
        ensureNumberFormatIsMutable();
        numberFormat_.add(index, builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder addAllNumberFormat(
          java.lang.Iterable<? extends com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> values) {
        ensureNumberFormatIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, numberFormat_);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder clearNumberFormat() {
        numberFormat_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x02000000);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat number_format = 19;</code>
       *
       * <pre>
       * Note that the number format here is used for formatting only, not parsing.
       * Hence all the varied ways a user *may* write a number need not be recorded
       * - just the ideal way we would like to format it for them. When this element
       * is absent, the national significant number will be formatted as a whole
       * without any formatting applied.
       * </pre>
       */
      public Builder removeNumberFormat(int index) {
        ensureNumberFormatIsMutable();
        numberFormat_.remove(index);

        return this;
      }

      private java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> intlNumberFormat_ =
        java.util.Collections.emptyList();
      private void ensureIntlNumberFormatIsMutable() {
        if (!((bitField0_ & 0x04000000) == 0x04000000)) {
          intlNumberFormat_ = new java.util.ArrayList<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat>(intlNumberFormat_);
          bitField0_ |= 0x04000000;
         }
      }

      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public java.util.List<com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> getIntlNumberFormatList() {
        return java.util.Collections.unmodifiableList(intlNumberFormat_);
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public int getIntlNumberFormatCount() {
        return intlNumberFormat_.size();
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.NumberFormat getIntlNumberFormat(int index) {
        return intlNumberFormat_.get(index);
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder setIntlNumberFormat(
          int index, com.google.i18n.phonenumbers.Phonemetadata.NumberFormat value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureIntlNumberFormatIsMutable();
        intlNumberFormat_.set(index, value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder setIntlNumberFormat(
          int index, com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.Builder builderForValue) {
        ensureIntlNumberFormatIsMutable();
        intlNumberFormat_.set(index, builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder addIntlNumberFormat(com.google.i18n.phonenumbers.Phonemetadata.NumberFormat value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureIntlNumberFormatIsMutable();
        intlNumberFormat_.add(value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder addIntlNumberFormat(
          int index, com.google.i18n.phonenumbers.Phonemetadata.NumberFormat value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureIntlNumberFormatIsMutable();
        intlNumberFormat_.add(index, value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder addIntlNumberFormat(
          com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.Builder builderForValue) {
        ensureIntlNumberFormatIsMutable();
        intlNumberFormat_.add(builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder addIntlNumberFormat(
          int index, com.google.i18n.phonenumbers.Phonemetadata.NumberFormat.Builder builderForValue) {
        ensureIntlNumberFormatIsMutable();
        intlNumberFormat_.add(index, builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder addAllIntlNumberFormat(
          java.lang.Iterable<? extends com.google.i18n.phonenumbers.Phonemetadata.NumberFormat> values) {
        ensureIntlNumberFormatIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, intlNumberFormat_);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder clearIntlNumberFormat() {
        intlNumberFormat_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x04000000);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.NumberFormat intl_number_format = 20;</code>
       *
       * <pre>
       * This field is populated only when the national significant number is
       * formatted differently when it forms part of the INTERNATIONAL format
       * and NATIONAL format. A case in point is mobile numbers in Argentina:
       * The number, which would be written in INTERNATIONAL format as
       * +54 9 343 555 1212, will be written as 0343 15 555 1212 for NATIONAL
       * format. In this case, the prefix 9 is inserted when dialling from
       * overseas, but otherwise the prefix 0 and the carrier selection code
       * 15 (inserted after the area code of 343) is used.
       * Note: this field is populated by setting a value for &lt;intlFormat&gt; inside
       * the &lt;numberFormat&gt; tag in the XML file. If &lt;intlFormat&gt; is not set then it
       * defaults to the same value as the &lt;format&gt; tag.
       * Examples:
       *   To set the &lt;intlFormat&gt; to a different value than the &lt;format&gt;:
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;$1-$2-$3&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       *   To have a format only used for national formatting, set &lt;intlFormat&gt; to
       *   "NA":
       *     &lt;numberFormat pattern=....&gt;
       *       &lt;format&gt;$1 $2 $3&lt;/format&gt;
       *       &lt;intlFormat&gt;NA&lt;/intlFormat&gt;
       *     &lt;/numberFormat&gt;
       * </pre>
       */
      public Builder removeIntlNumberFormat(int index) {
        ensureIntlNumberFormatIsMutable();
        intlNumberFormat_.remove(index);

        return this;
      }

      private boolean mainCountryForCode_ ;
      /**
       * <code>optional bool main_country_for_code = 22 [default = false];</code>
       *
       * <pre>
       * This field is set when this country is considered to be the main country
       * for a calling code. It may not be set by more than one country with the
       * same calling code, and it should not be set by countries with a unique
       * calling code. This can be used to indicate that "GB" is the main country
       * for the calling code "44" for example, rather than Jersey or the Isle of
       * Man.
       * </pre>
       */
      public boolean hasMainCountryForCode() {
        return ((bitField0_ & 0x08000000) == 0x08000000);
      }
      /**
       * <code>optional bool main_country_for_code = 22 [default = false];</code>
       *
       * <pre>
       * This field is set when this country is considered to be the main country
       * for a calling code. It may not be set by more than one country with the
       * same calling code, and it should not be set by countries with a unique
       * calling code. This can be used to indicate that "GB" is the main country
       * for the calling code "44" for example, rather than Jersey or the Isle of
       * Man.
       * </pre>
       */
      public boolean getMainCountryForCode() {
        return mainCountryForCode_;
      }
      /**
       * <code>optional bool main_country_for_code = 22 [default = false];</code>
       *
       * <pre>
       * This field is set when this country is considered to be the main country
       * for a calling code. It may not be set by more than one country with the
       * same calling code, and it should not be set by countries with a unique
       * calling code. This can be used to indicate that "GB" is the main country
       * for the calling code "44" for example, rather than Jersey or the Isle of
       * Man.
       * </pre>
       */
      public Builder setMainCountryForCode(boolean value) {
        bitField0_ |= 0x08000000;
        mainCountryForCode_ = value;
        
        return this;
      }
      /**
       * <code>optional bool main_country_for_code = 22 [default = false];</code>
       *
       * <pre>
       * This field is set when this country is considered to be the main country
       * for a calling code. It may not be set by more than one country with the
       * same calling code, and it should not be set by countries with a unique
       * calling code. This can be used to indicate that "GB" is the main country
       * for the calling code "44" for example, rather than Jersey or the Isle of
       * Man.
       * </pre>
       */
      public Builder clearMainCountryForCode() {
        bitField0_ = (bitField0_ & ~0x08000000);
        mainCountryForCode_ = false;
        
        return this;
      }

      private java.lang.Object leadingDigits_ = "";
      /**
       * <code>optional string leading_digits = 23;</code>
       *
       * <pre>
       * This field is populated only for countries or regions that share a country
       * calling code. If a number matches this pattern, it could belong to this
       * region. This is not intended as a replacement for IsValidForRegion, and
       * does not mean the number must come from this region (for example, 800
       * numbers are valid for all NANPA countries.) This field should be a regular
       * expression of the expected prefix match.
       * </pre>
       */
      public boolean hasLeadingDigits() {
        return ((bitField0_ & 0x10000000) == 0x10000000);
      }
      /**
       * <code>optional string leading_digits = 23;</code>
       *
       * <pre>
       * This field is populated only for countries or regions that share a country
       * calling code. If a number matches this pattern, it could belong to this
       * region. This is not intended as a replacement for IsValidForRegion, and
       * does not mean the number must come from this region (for example, 800
       * numbers are valid for all NANPA countries.) This field should be a regular
       * expression of the expected prefix match.
       * </pre>
       */
      public java.lang.String getLeadingDigits() {
        java.lang.Object ref = leadingDigits_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            leadingDigits_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string leading_digits = 23;</code>
       *
       * <pre>
       * This field is populated only for countries or regions that share a country
       * calling code. If a number matches this pattern, it could belong to this
       * region. This is not intended as a replacement for IsValidForRegion, and
       * does not mean the number must come from this region (for example, 800
       * numbers are valid for all NANPA countries.) This field should be a regular
       * expression of the expected prefix match.
       * </pre>
       */
      public com.google.protobuf.ByteString
          getLeadingDigitsBytes() {
        java.lang.Object ref = leadingDigits_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          leadingDigits_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string leading_digits = 23;</code>
       *
       * <pre>
       * This field is populated only for countries or regions that share a country
       * calling code. If a number matches this pattern, it could belong to this
       * region. This is not intended as a replacement for IsValidForRegion, and
       * does not mean the number must come from this region (for example, 800
       * numbers are valid for all NANPA countries.) This field should be a regular
       * expression of the expected prefix match.
       * </pre>
       */
      public Builder setLeadingDigits(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x10000000;
        leadingDigits_ = value;
        
        return this;
      }
      /**
       * <code>optional string leading_digits = 23;</code>
       *
       * <pre>
       * This field is populated only for countries or regions that share a country
       * calling code. If a number matches this pattern, it could belong to this
       * region. This is not intended as a replacement for IsValidForRegion, and
       * does not mean the number must come from this region (for example, 800
       * numbers are valid for all NANPA countries.) This field should be a regular
       * expression of the expected prefix match.
       * </pre>
       */
      public Builder clearLeadingDigits() {
        bitField0_ = (bitField0_ & ~0x10000000);
        leadingDigits_ = getDefaultInstance().getLeadingDigits();
        
        return this;
      }
      /**
       * <code>optional string leading_digits = 23;</code>
       *
       * <pre>
       * This field is populated only for countries or regions that share a country
       * calling code. If a number matches this pattern, it could belong to this
       * region. This is not intended as a replacement for IsValidForRegion, and
       * does not mean the number must come from this region (for example, 800
       * numbers are valid for all NANPA countries.) This field should be a regular
       * expression of the expected prefix match.
       * </pre>
       */
      public Builder setLeadingDigitsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x10000000;
        leadingDigits_ = value;
        
        return this;
      }

      private boolean leadingZeroPossible_ ;
      /**
       * <code>optional bool leading_zero_possible = 26 [default = false];</code>
       *
       * <pre>
       * The leading zero in a phone number is meaningful in some countries (e.g.
       * Italy). This means they cannot be dropped from the national number when
       * converting into international format. If leading zeros are possible for
       * valid international numbers for this region/country then set this to true.
       * This only needs to be set for the region that is the main_country_for_code
       * and all regions associated with that calling code will use the same
       * setting.
       * </pre>
       */
      public boolean hasLeadingZeroPossible() {
        return ((bitField0_ & 0x20000000) == 0x20000000);
      }
      /**
       * <code>optional bool leading_zero_possible = 26 [default = false];</code>
       *
       * <pre>
       * The leading zero in a phone number is meaningful in some countries (e.g.
       * Italy). This means they cannot be dropped from the national number when
       * converting into international format. If leading zeros are possible for
       * valid international numbers for this region/country then set this to true.
       * This only needs to be set for the region that is the main_country_for_code
       * and all regions associated with that calling code will use the same
       * setting.
       * </pre>
       */
      public boolean getLeadingZeroPossible() {
        return leadingZeroPossible_;
      }
      /**
       * <code>optional bool leading_zero_possible = 26 [default = false];</code>
       *
       * <pre>
       * The leading zero in a phone number is meaningful in some countries (e.g.
       * Italy). This means they cannot be dropped from the national number when
       * converting into international format. If leading zeros are possible for
       * valid international numbers for this region/country then set this to true.
       * This only needs to be set for the region that is the main_country_for_code
       * and all regions associated with that calling code will use the same
       * setting.
       * </pre>
       */
      public Builder setLeadingZeroPossible(boolean value) {
        bitField0_ |= 0x20000000;
        leadingZeroPossible_ = value;
        
        return this;
      }
      /**
       * <code>optional bool leading_zero_possible = 26 [default = false];</code>
       *
       * <pre>
       * The leading zero in a phone number is meaningful in some countries (e.g.
       * Italy). This means they cannot be dropped from the national number when
       * converting into international format. If leading zeros are possible for
       * valid international numbers for this region/country then set this to true.
       * This only needs to be set for the region that is the main_country_for_code
       * and all regions associated with that calling code will use the same
       * setting.
       * </pre>
       */
      public Builder clearLeadingZeroPossible() {
        bitField0_ = (bitField0_ & ~0x20000000);
        leadingZeroPossible_ = false;
        
        return this;
      }

      private boolean mobileNumberPortableRegion_ ;
      /**
       * <code>optional bool mobile_number_portable_region = 32 [default = false];</code>
       *
       * <pre>
       * This field is set when this country has implemented mobile number
       * portability. This means that transferring mobile numbers between carriers
       * is allowed. A consequence of this is that phone prefix to carrier mapping
       * is less reliable.
       * </pre>
       */
      public boolean hasMobileNumberPortableRegion() {
        return ((bitField0_ & 0x40000000) == 0x40000000);
      }
      /**
       * <code>optional bool mobile_number_portable_region = 32 [default = false];</code>
       *
       * <pre>
       * This field is set when this country has implemented mobile number
       * portability. This means that transferring mobile numbers between carriers
       * is allowed. A consequence of this is that phone prefix to carrier mapping
       * is less reliable.
       * </pre>
       */
      public boolean getMobileNumberPortableRegion() {
        return mobileNumberPortableRegion_;
      }
      /**
       * <code>optional bool mobile_number_portable_region = 32 [default = false];</code>
       *
       * <pre>
       * This field is set when this country has implemented mobile number
       * portability. This means that transferring mobile numbers between carriers
       * is allowed. A consequence of this is that phone prefix to carrier mapping
       * is less reliable.
       * </pre>
       */
      public Builder setMobileNumberPortableRegion(boolean value) {
        bitField0_ |= 0x40000000;
        mobileNumberPortableRegion_ = value;
        
        return this;
      }
      /**
       * <code>optional bool mobile_number_portable_region = 32 [default = false];</code>
       *
       * <pre>
       * This field is set when this country has implemented mobile number
       * portability. This means that transferring mobile numbers between carriers
       * is allowed. A consequence of this is that phone prefix to carrier mapping
       * is less reliable.
       * </pre>
       */
      public Builder clearMobileNumberPortableRegion() {
        bitField0_ = (bitField0_ & ~0x40000000);
        mobileNumberPortableRegion_ = false;
        
        return this;
      }

      // @@protoc_insertion_point(builder_scope:i18n.phonenumbers.PhoneMetadata)
    }

    static {
      defaultInstance = new PhoneMetadata(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:i18n.phonenumbers.PhoneMetadata)
  }

  public interface PhoneMetadataCollectionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:i18n.phonenumbers.PhoneMetadataCollection)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
     */
    java.util.List<com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata> 
        getMetadataList();
    /**
     * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
     */
    com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata getMetadata(int index);
    /**
     * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
     */
    int getMetadataCount();
  }
  /**
   * Protobuf type {@code i18n.phonenumbers.PhoneMetadataCollection}
   */
  public static final class PhoneMetadataCollection extends
      com.google.protobuf.GeneratedMessageLite implements
      // @@protoc_insertion_point(message_implements:i18n.phonenumbers.PhoneMetadataCollection)
      PhoneMetadataCollectionOrBuilder {
    // Use PhoneMetadataCollection.newBuilder() to construct.
    private PhoneMetadataCollection(com.google.protobuf.GeneratedMessageLite.Builder builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }
    private PhoneMetadataCollection(boolean noInit) { this.unknownFields = com.google.protobuf.ByteString.EMPTY;}

    private static final PhoneMetadataCollection defaultInstance;
    public static PhoneMetadataCollection getDefaultInstance() {
      return defaultInstance;
    }

    public PhoneMetadataCollection getDefaultInstanceForType() {
      return defaultInstance;
    }

    private final com.google.protobuf.ByteString unknownFields;
    private PhoneMetadataCollection(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      initFields();
      int mutable_bitField0_ = 0;
      com.google.protobuf.ByteString.Output unknownFieldsOutput =
          com.google.protobuf.ByteString.newOutput();
      com.google.protobuf.CodedOutputStream unknownFieldsCodedOutput =
          com.google.protobuf.CodedOutputStream.newInstance(
              unknownFieldsOutput);
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(input, unknownFieldsCodedOutput,
                                     extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                metadata_ = new java.util.ArrayList<com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata>();
                mutable_bitField0_ |= 0x00000001;
              }
              metadata_.add(input.readMessage(com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata.PARSER, extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e.getMessage()).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          metadata_ = java.util.Collections.unmodifiableList(metadata_);
        }
        try {
          unknownFieldsCodedOutput.flush();
        } catch (java.io.IOException e) {
        // Should not happen
        } finally {
          unknownFields = unknownFieldsOutput.toByteString();
        }
        makeExtensionsImmutable();
      }
    }
    public static com.google.protobuf.Parser<PhoneMetadataCollection> PARSER =
        new com.google.protobuf.AbstractParser<PhoneMetadataCollection>() {
      public PhoneMetadataCollection parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PhoneMetadataCollection(input, extensionRegistry);
      }
    };

    @java.lang.Override
    public com.google.protobuf.Parser<PhoneMetadataCollection> getParserForType() {
      return PARSER;
    }

    public static final int METADATA_FIELD_NUMBER = 1;
    private java.util.List<com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata> metadata_;
    /**
     * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
     */
    public java.util.List<com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata> getMetadataList() {
      return metadata_;
    }
    /**
     * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
     */
    public java.util.List<? extends com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataOrBuilder> 
        getMetadataOrBuilderList() {
      return metadata_;
    }
    /**
     * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
     */
    public int getMetadataCount() {
      return metadata_.size();
    }
    /**
     * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata getMetadata(int index) {
      return metadata_.get(index);
    }
    /**
     * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
     */
    public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataOrBuilder getMetadataOrBuilder(
        int index) {
      return metadata_.get(index);
    }

    private void initFields() {
      metadata_ = java.util.Collections.emptyList();
    }
    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getMetadataCount(); i++) {
        if (!getMetadata(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      for (int i = 0; i < metadata_.size(); i++) {
        output.writeMessage(1, metadata_.get(i));
      }
      output.writeRawBytes(unknownFields);
    }

    private int memoizedSerializedSize = -1;
    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < metadata_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, metadata_.get(i));
      }
      size += unknownFields.size();
      memoizedSerializedSize = size;
      return size;
    }

    private static final long serialVersionUID = 0L;
    @java.lang.Override
    protected java.lang.Object writeReplace()
        throws java.io.ObjectStreamException {
      return super.writeReplace();
    }

    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return PARSER.parseFrom(input);
    }
    public static com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() { return Builder.create(); }
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder(com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection prototype) {
      return newBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() { return newBuilder(this); }

    /**
     * Protobuf type {@code i18n.phonenumbers.PhoneMetadataCollection}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection, Builder>
        implements
        // @@protoc_insertion_point(builder_implements:i18n.phonenumbers.PhoneMetadataCollection)
        com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollectionOrBuilder {
      // Construct using com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        metadata_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection getDefaultInstanceForType() {
        return com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection.getDefaultInstance();
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection build() {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection buildPartial() {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection result = new com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection(this);
        int from_bitField0_ = bitField0_;
        if (((bitField0_ & 0x00000001) == 0x00000001)) {
          metadata_ = java.util.Collections.unmodifiableList(metadata_);
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.metadata_ = metadata_;
        return result;
      }

      public Builder mergeFrom(com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection other) {
        if (other == com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection.getDefaultInstance()) return this;
        if (!other.metadata_.isEmpty()) {
          if (metadata_.isEmpty()) {
            metadata_ = other.metadata_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureMetadataIsMutable();
            metadata_.addAll(other.metadata_);
          }
          
        }
        setUnknownFields(
            getUnknownFields().concat(other.unknownFields));
        return this;
      }

      public final boolean isInitialized() {
        for (int i = 0; i < getMetadataCount(); i++) {
          if (!getMetadata(i).isInitialized()) {
            
            return false;
          }
        }
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadataCollection) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata> metadata_ =
        java.util.Collections.emptyList();
      private void ensureMetadataIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          metadata_ = new java.util.ArrayList<com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata>(metadata_);
          bitField0_ |= 0x00000001;
         }
      }

      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public java.util.List<com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata> getMetadataList() {
        return java.util.Collections.unmodifiableList(metadata_);
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public int getMetadataCount() {
        return metadata_.size();
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata getMetadata(int index) {
        return metadata_.get(index);
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder setMetadata(
          int index, com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMetadataIsMutable();
        metadata_.set(index, value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder setMetadata(
          int index, com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata.Builder builderForValue) {
        ensureMetadataIsMutable();
        metadata_.set(index, builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder addMetadata(com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMetadataIsMutable();
        metadata_.add(value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder addMetadata(
          int index, com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMetadataIsMutable();
        metadata_.add(index, value);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder addMetadata(
          com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata.Builder builderForValue) {
        ensureMetadataIsMutable();
        metadata_.add(builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder addMetadata(
          int index, com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata.Builder builderForValue) {
        ensureMetadataIsMutable();
        metadata_.add(index, builderForValue.build());

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder addAllMetadata(
          java.lang.Iterable<? extends com.google.i18n.phonenumbers.Phonemetadata.PhoneMetadata> values) {
        ensureMetadataIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, metadata_);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder clearMetadata() {
        metadata_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);

        return this;
      }
      /**
       * <code>repeated .i18n.phonenumbers.PhoneMetadata metadata = 1;</code>
       */
      public Builder removeMetadata(int index) {
        ensureMetadataIsMutable();
        metadata_.remove(index);

        return this;
      }

      // @@protoc_insertion_point(builder_scope:i18n.phonenumbers.PhoneMetadataCollection)
    }

    static {
      defaultInstance = new PhoneMetadataCollection(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:i18n.phonenumbers.PhoneMetadataCollection)
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
